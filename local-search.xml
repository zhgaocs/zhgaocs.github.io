<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Keyword in C++ - alignas</title>
    <link href="/2023/11/23/keyword-alignas/"/>
    <url>/2023/11/23/keyword-alignas/</url>
    
    <content type="html"><![CDATA[<h1 id="C-关键字—alignas"><a href="#C-关键字—alignas" class="headerlink" title="C++关键字—alignas"></a>C++关键字—<code>alignas</code></h1><h2 id="1-标准"><a href="#1-标准" class="headerlink" title="1. 标准"></a>1. 标准</h2><p>C++11</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>指定类型或对象的对齐要求</p><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3. 语法"></a>3. 语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">alignas</span>(expression); <span class="hljs-comment">// 表达式必须是一个整型常量表达式，其值为零或者是合法的对齐或扩展对齐</span><br><span class="hljs-built_in">alignas</span>(type-id);    <span class="hljs-comment">// 等价于alignas(alignof(类型标识))，即将对齐方式设置为指定类型的对齐要求</span><br><span class="hljs-built_in">alignas</span>(pack...);    <span class="hljs-comment">// 等价于为模板参数包中每个模板参数使用alignas</span><br></code></pre></td></tr></table></figure><h2 id="4-alignas用法"><a href="#4-alignas用法" class="headerlink" title="4. alignas用法"></a>4. <code>alignas</code>用法</h2><h3 id="4-1-类的声明或定义"><a href="#4-1-类的声明或定义" class="headerlink" title="4.1 类的声明或定义"></a>4.1 类的声明或定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">alignas</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>; <span class="hljs-comment">// 用于类的声明</span><br><span class="hljs-built_in">alignas</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span><br>&#123;<br>    S s<br>&#125;; <span class="hljs-comment">// 用于类的定义</span><br></code></pre></td></tr></table></figure><h3 id="4-2-非位域类数据成员的声明"><a href="#4-2-非位域类数据成员的声明" class="headerlink" title="4.2 非位域类数据成员的声明"></a>4.2 非位域类数据成员的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;; <span class="hljs-comment">// alignof(S) == 16</span><br></code></pre></td></tr></table></figure><p>位域类数据成员是按位定义的结构体成员，可指定其占用的位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> day   : <span class="hljs-number">5</span>;  <span class="hljs-comment">// 位域类型数据成员，占用5位，表示1-31</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> month : <span class="hljs-number">4</span>;  <span class="hljs-comment">// 位域类型数据成员，占用4位，表示1-12</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> year  : <span class="hljs-number">11</span>; <span class="hljs-comment">// 位域类型数据成员，占用11位，表示0-2047</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-3-变量声明"><a href="#4-3-变量声明" class="headerlink" title="4.3 变量声明"></a>4.3 变量声明</h3><p>除了不能应用于下列内容</p><ul><li><p>函数形参</p></li><li><p><code>catch</code>子句的异常形参</p></li></ul><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5. 注意"></a>5. 注意</h2><ul><li><p>有效的对齐应为2的幂</p></li><li><p><code>alignas</code>不能弱化原生对齐</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) S<br>&#123;<br>    <span class="hljs-type">float</span> f;<br>    <span class="hljs-type">double</span> d;<br>&#125;; <span class="hljs-comment">// alignof(S) == 8</span><br></code></pre></td></tr></table></figure><ul><li>最大的有效<code>alignas</code>声明生效，其余被忽略</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">alignas</span>(<span class="hljs-number">32</span>) <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) <span class="hljs-type">int</span> i; <span class="hljs-comment">// alignof(i) == 32</span><br></code></pre></td></tr></table></figure><ul><li>始终忽略<code>alignas(0)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Keyword</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keyword in C++ - alignof</title>
    <link href="/2023/11/22/keyword-alignof/"/>
    <url>/2023/11/22/keyword-alignof/</url>
    
    <content type="html"><![CDATA[<h1 id="C-关键字—alignof"><a href="#C-关键字—alignof" class="headerlink" title="C++关键字—alignof"></a>C++关键字—<code>alignof</code></h1><h2 id="1-标准"><a href="#1-标准" class="headerlink" title="1. 标准"></a>1. 标准</h2><p>C++11</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>查询类型的对齐要求</p><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3. 语法"></a>3. 语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">alignof</span>(type-id);<br></code></pre></td></tr></table></figure><p>返回值类型为<code>std::size_t</code></p><h2 id="4-对齐要求"><a href="#4-对齐要求" class="headerlink" title="4. 对齐要求"></a>4. 对齐要求</h2><ul><li><strong>基础类型</strong>：对齐要求等于类型的存储大小</li><li><strong>类类型</strong>：对齐要求是其成员变量中最大的对齐要求</li></ul><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5. 注意"></a>5. 注意</h2><ul><li><code>type-id</code>为引用类型，<code>alignof</code>返回的是<strong>被引用</strong>类型的对齐要求</li><li><code>type-id</code>为数组类型，<code>alignof</code>返回的是<strong>数组元素</strong>类型的对齐要求</li></ul><h2 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    <span class="hljs-type">bool</span> b;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">float</span> f;<br>    <span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-type">int</span> i, &amp;ri = i;<br>S arr[<span class="hljs-number">2</span>];<br><br><span class="hljs-built_in">alignof</span>(ri);  <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">alignof</span>(S);   <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">alignof</span>(arr); <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">sizeof</span>(S);    <span class="hljs-comment">// 24</span><br><span class="hljs-built_in">sizeof</span>(arr);  <span class="hljs-comment">// 48</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Keyword</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Mutex and Locking (Part 1)</title>
    <link href="/2023/11/14/mutex-and-locking-1/"/>
    <url>/2023/11/14/mutex-and-locking-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-互斥和锁定（一）"><a href="#C-互斥和锁定（一）" class="headerlink" title="C++互斥和锁定（一）"></a>C++互斥和锁定（一）</h1><h2 id="1-std-mutex类"><a href="#1-std-mutex类" class="headerlink" title="1. std::mutex类"></a>1. <code>std::mutex</code>类</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>std::mutex</code>用于保护共享数据免受多个线程同时访问的同步原语，定义在头文件<code>&lt;mutex&gt;</code>中</p><h3 id="1-2-构造函数和析构函数"><a href="#1-2-构造函数和析构函数" class="headerlink" title="1.2 构造函数和析构函数"></a>1.2 构造函数和析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">mutex</span>();<br>~<span class="hljs-built_in">mutex</span>();<br></code></pre></td></tr></table></figure><h3 id="1-3-锁定"><a href="#1-3-锁定" class="headerlink" title="1.3 锁定"></a>1.3 锁定</h3><ul><li><code>lock</code>：锁定互斥。若另一线程已锁定互斥，则到<code>lock</code>的调用将阻塞执行，直至获得锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>try_lock</code>：尝试锁定互斥，立即返回。成功获得锁时返回<code>true</code>，否则返回<code>false</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>unlock</code>：解锁互斥<em>（互斥必须为当前执行线程所锁定，否则行为未定义）</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="1-4-mutex所有权"><a href="#1-4-mutex所有权" class="headerlink" title="1.4 mutex所有权"></a>1.4 <code>mutex</code>所有权</h3><ul><li>一个线程在成功调用<code>lock</code>或<code>try_lock</code>后，直到调用<code>unlock</code>之前，都被视为拥有<code>mutex</code></li><li>当一个线程拥有<code>mutex</code>时，任何其他试图获取<code>mutex</code>所有权的线程都将被阻塞，即<code>lock</code>调用将被阻塞，或者<code>try_lock</code>将返回<code>false</code></li><li>在调用<code>lock</code>或<code>try_lock</code>之前，调用方线程必须确保自己不拥有<code>mutex</code></li></ul><h3 id="1-5-注意"><a href="#1-5-注意" class="headerlink" title="1.5 注意"></a>1.5 注意</h3><ul><li>通常不直接使用<code>std::mutex</code>，<code>std::unique_lock</code>、<code>std::lock_guard</code>或<code>std::scoped_lock</code><em>（C++17起）</em>以更加异常安全的方式管理锁定</li><li><code>std::mutex</code>既<strong>不可拷贝</strong>也<strong>不可移动</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">mutex</span>(<span class="hljs-type">const</span> mutex &amp;) = <span class="hljs-keyword">delete</span>;<br>mutex &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> mutex &amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><h2 id="2-互斥包装器概览"><a href="#2-互斥包装器概览" class="headerlink" title="2. 互斥包装器概览"></a>2. 互斥包装器概览</h2><h3 id="2-1-锁定策略"><a href="#2-1-锁定策略" class="headerlink" title="2.1 锁定策略"></a>2.1 锁定策略</h3><h4 id="2-1-1-锁定策略的标记类型"><a href="#2-1-1-锁定策略的标记类型" class="headerlink" title="2.1.1 锁定策略的标记类型"></a>2.1.1 锁定策略的标记类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">defer_lock_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">defer_lock_t</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">try_to_lock_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">try_to_lock_t</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">adopt_lock_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">adopt_lock_t</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-1-2-标记类型的含义"><a href="#2-1-2-标记类型的含义" class="headerlink" title="2.1.2 标记类型的含义"></a>2.1.2 标记类型的含义</h4><table><thead><tr><th align="center">类型</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>defer_lock_t</code></td><td align="center">不获得互斥的所有权</td></tr><tr><td align="center"><code>try_to_lock_t</code></td><td align="center">尝试获得互斥的所有权而不阻塞</td></tr><tr><td align="center"><code>adopt_lock_t</code></td><td align="center">假设调用方线程已拥有互斥的所有权</td></tr></tbody></table><h3 id="2-2-锁定概念的比较"><a href="#2-2-锁定概念的比较" class="headerlink" title="2.2 锁定概念的比较"></a>2.2 锁定概念的比较</h3><table><thead><tr><th align="center">概念</th><th align="center">成员函数要求</th></tr></thead><tbody><tr><td align="center">基本可锁定</td><td align="center"><code>lock</code>、<code>unlock</code></td></tr><tr><td align="center">可锁定</td><td align="center"><code>lock</code>、<code>unlock</code>、<code>try_lock</code></td></tr><tr><td align="center">可定时锁定</td><td align="center"><code>lock</code>、<code>unlock</code>、<code>try_lock</code>、<code>try_lock_for</code>、<code>try_lock_until</code></td></tr></tbody></table><h3 id="2-3-互斥包装器类模板声明"><a href="#2-3-互斥包装器类模板声明" class="headerlink" title="2.3 互斥包装器类模板声明"></a>2.3 互斥包装器类模板声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... MutexTypes&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_lock</span>;<br></code></pre></td></tr></table></figure><p>类模板参数要求</p><table><thead><tr><th align="center">包装器</th><th align="center">模板形参（锁）的要求</th></tr></thead><tbody><tr><td align="center"><code>std::unique_lock</code></td><td align="center">基本可锁定</td></tr><tr><td align="center"><code>std::lock_guard</code></td><td align="center">基本可锁定</td></tr><tr><td align="center"><code>std::scoped_lock</code></td><td align="center">可锁定（模板参数个数为1时只需满足基本可锁定）</td></tr></tbody></table><h3 id="2-4-成员类型"><a href="#2-4-成员类型" class="headerlink" title="2.4 成员类型"></a>2.4 成员类型</h3><table><thead><tr><th align="center">成员类型</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center"><code>mutex_type</code>（仅当<code>std::scoped_lock</code>的<code>sizeof...(MutexTypes) == 1</code>时有效）</td><td align="center"><code>Mutex</code></td></tr></tbody></table><h3 id="2-5-互斥包装器对比分析"><a href="#2-5-互斥包装器对比分析" class="headerlink" title="2.5 互斥包装器对比分析"></a>2.5 互斥包装器对比分析</h3><table><thead><tr><th align="center">特性</th><th align="center"><code>std::unique_lock</code></th><th align="center"><code>std::lock_guard</code></th><th align="center"><code>std::scoped_lock</code></th></tr></thead><tbody><tr><td align="center">标准</td><td align="center">C++11</td><td align="center">C++11</td><td align="center">C++17</td></tr><tr><td align="center">锁定策略</td><td align="center">立即锁定、延迟锁定、尝试锁定和采用锁定</td><td align="center">只支持立即锁定</td><td align="center">只支持立即锁定</td></tr><tr><td align="center">是否支持手动锁定和解锁</td><td align="center">支持</td><td align="center">不支持</td><td align="center">不支持</td></tr><tr><td align="center">是否能与条件变量配合使用</td><td align="center">能</td><td align="center">不能</td><td align="center">不能</td></tr><tr><td align="center">是否支持锁定多个互斥量</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">包装器对象是否可拷贝</td><td align="center">不可拷贝</td><td align="center">不可拷贝</td><td align="center">不可拷贝</td></tr><tr><td align="center">包装器对象是否可移动</td><td align="center">可移动</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">效率和内存占用</td><td align="center">效率较低，内存占用稍高</td><td align="center">效率较高，内存占用较低</td><td align="center">效率较高，内存占用较低</td></tr></tbody></table><h2 id="3-std-unique-lock类"><a href="#3-std-unique-lock类" class="headerlink" title="3. std::unique_lock类"></a>3. <code>std::unique_lock</code>类</h2><h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 构造无关联互斥的unique_lock</span><br><span class="hljs-built_in">unique_lock</span>(unique_lock &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span><span class="hljs-params">(mutex_type &amp;m)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unique_lock</span>(mutex_type &amp;m, std::<span class="hljs-type">defer_lock_t</span> t) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-built_in">unique_lock</span>(mutex_type &amp;m, std::<span class="hljs-type">try_to_lock_t</span> t);<br><span class="hljs-built_in">unique_lock</span>(mutex_type &amp;m, std::<span class="hljs-type">adopt_lock_t</span> t);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span>&gt;<br><span class="hljs-built_in">unique_lock</span>(mutex_type &amp;m, <span class="hljs-type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout_duration);<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span>&gt;<br><span class="hljs-built_in">unique_lock</span>(mutex_type &amp;m, <span class="hljs-type">const</span> std::chrono::time_point&lt;Clock, Duration&gt; &amp;timeout_time);<br></code></pre></td></tr></table></figure><h3 id="3-2-析构函数"><a href="#3-2-析构函数" class="headerlink" title="3.2 析构函数"></a>3.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">unique_lock</span>(); <span class="hljs-comment">// 销毁锁。若*this拥有关联互斥且获得了其所有权，则解锁互斥</span><br></code></pre></td></tr></table></figure><h3 id="3-3-移动赋值运算符"><a href="#3-3-移动赋值运算符" class="headerlink" title="3.3 移动赋值运算符"></a>3.3 移动赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用移动语义以other的内容替换*this内容。</span><br><span class="hljs-comment"> * 若调用前*this拥有关联互斥并获得其所有权，则解锁互斥</span><br><span class="hljs-comment"> */</span><br>unique_lock &amp;<span class="hljs-keyword">operator</span>=(unique_lock &amp;&amp;other);<br></code></pre></td></tr></table></figure><h3 id="3-4-锁定"><a href="#3-4-锁定" class="headerlink" title="3.4 锁定"></a>3.4 锁定</h3><ul><li><code>lock</code>：锁定关联互斥。等效调用<code>mutex()-&gt;lock()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>try_lock</code>：尝试锁定关联互斥而不阻塞。等效调用<code>mutex()-&gt;try_lock()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>try_lock_for</code>：在指定的时间段内尝试获取互斥</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span>&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock_for</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout_duration)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::timed_mutex tmtx;<br><span class="hljs-function">std::unique_lock&lt;std::timed_mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(tmtx, std::defer_lock)</span></span>;<br><br>lck.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br></code></pre></td></tr></table></figure><ul><li><code>try_lock_until</code>：在指定的时间点之前尝试获取互斥</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span>&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::time_point&lt;Clock, Duration&gt; &amp;timeout_time)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::timed_mutex tmtx;<br><span class="hljs-function">std::unique_lock&lt;std::timed_mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(tmtx, std::defer_lock)</span></span>;<br><br><span class="hljs-keyword">auto</span> now = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>lck.<span class="hljs-built_in">try_lock_until</span>(now + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><ul><li><code>unlock</code>：解锁关联互斥并释放所有权</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-修改器"><a href="#3-5-修改器" class="headerlink" title="3.5 修改器"></a>3.5 修改器</h3><ul><li><code>swap</code>：与另一<code>std::unique_lock</code> 交换状态</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_lock &amp;other)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>release</code>：将关联互斥解关联而不解锁它</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">mutex_type *<span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-6-观察器"><a href="#3-6-观察器" class="headerlink" title="3.6 观察器"></a>3.6 观察器</h3><ul><li><code>mutex</code>：返回指向关联互斥的指针，或若无关联互斥则返回空指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">mutex_type *<span class="hljs-title">mutex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>owns_lock</code>：测试锁是否占有其关联互斥</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">owns_lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>operator bool</code>：测试锁是否占有其关联互斥。等效调用<code>owns_lock()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::mutex mtx;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br><br><span class="hljs-keyword">if</span> (lck)<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Mutex is locked.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">else</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Mutex is not locked.&quot;</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h2 id="4-std-lock-guard类"><a href="#4-std-lock-guard类" class="headerlink" title="4. std::lock_guard类"></a>4. <code>std::lock_guard</code>类</h2><h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_type &amp;m)</span></span>;             <span class="hljs-comment">// 等效调用m.lock()</span><br><span class="hljs-built_in">lock_guard</span>(mutex_type &amp;m, std::<span class="hljs-type">adopt_lock_t</span> t); <span class="hljs-comment">// 假定当前线程已拥有互斥m的所有权</span><br></code></pre></td></tr></table></figure><h3 id="4-2-析构函数"><a href="#4-2-析构函数" class="headerlink" title="4.2 析构函数"></a>4.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">lock_guard</span>(); <span class="hljs-comment">// 释放所占有的互斥，等效调用m.unlock()，其中m是传递给lock_guard的构造函数的互斥</span><br></code></pre></td></tr></table></figure><h2 id="5-std-scoped-lock类"><a href="#5-std-scoped-lock类" class="headerlink" title="5. std::scoped_lock类"></a>5. <code>std::scoped_lock</code>类</h2><h3 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_lock</span><span class="hljs-params">(MutexTypes &amp;...m)</span></span>;<br><span class="hljs-built_in">scoped_lock</span>(std::<span class="hljs-type">adopt_lock_t</span>, MutexTypes &amp;...m); <span class="hljs-comment">// 假定当前线程已拥有所有传入的互斥的所有权</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><code>sizeof...(MutexTypes)</code>的值</th><th align="center">行为</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">不做任何事</td></tr><tr><td align="center">1</td><td align="center">等效调用<code>m.lock()</code></td></tr><tr><td align="center">其它</td><td align="center">等效调用<code>std::lock(m..)</code></td></tr></tbody></table><h3 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">scoped_lock</span>(); <span class="hljs-comment">// 释放所有占有的互斥，相当于对传递给scoped_lock构造函数的每个互斥包中的互斥调用unlock()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Standard Library</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 14 - Advanced I/O</title>
    <link href="/2023/10/30/apue-ch14/"/>
    <url>/2023/10/30/apue-ch14/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-14-高级I-O"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-14-高级I-O" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 14 高级I&#x2F;O"></a>Advanced Programming in the UNIX Environment—Chapter 14 高级I&#x2F;O</h1><h2 id="1-非阻塞I-O"><a href="#1-非阻塞I-O" class="headerlink" title="1. 非阻塞I&#x2F;O"></a>1. 非阻塞I&#x2F;O</h2><h3 id="1-1-阻塞I-O与非阻塞I-O"><a href="#1-1-阻塞I-O与非阻塞I-O" class="headerlink" title="1.1 阻塞I&#x2F;O与非阻塞I&#x2F;O"></a>1.1 阻塞I&#x2F;O与非阻塞I&#x2F;O</h3><ul><li><p>阻塞I&#x2F;O：数据未就绪时，进程等待</p></li><li><p>非阻塞I&#x2F;O：数据未就绪时，进程继续执行</p></li></ul><h3 id="1-2-低速系统调用"><a href="#1-2-低速系统调用" class="headerlink" title="1.2 低速系统调用"></a>1.2 低速系统调用</h3><ul><li>对于某些文件类型（如管道、终端设备和网络设备），如果数据不存在，读操作会导致调用者阻塞</li><li>如果数据无法写入文件（如管道无空间、网络流控制等），写操作会导致调用者阻塞</li><li>打开某些类型的文件可能会导致阻塞</li><li>对已加强制性记录锁的文件进行读写</li><li>执行某些<code>ioctl</code>操作</li><li>使用某些进程间通信函数</li></ul><h3 id="1-3-设置非阻塞I-O"><a href="#1-3-设置非阻塞I-O" class="headerlink" title="1.3 设置非阻塞I&#x2F;O"></a>1.3 设置非阻塞I&#x2F;O</h3><ul><li>使用<code>open</code>函数和<code>O_NONBLOCK</code>标志打开新文件</li><li>对已打开的文件，用<code>fcntl</code>函数启用<code>O_NONBLOCK</code>标志</li></ul><h2 id="2-记录锁"><a href="#2-记录锁" class="headerlink" title="2. 记录锁"></a>2. 记录锁</h2><h3 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h3><p>当一个进程正在读取或修改文件的某个部分时，记录锁能阻止其他进程对同一文件区域进行修改</p><h3 id="2-2-结构体flock"><a href="#2-2-结构体flock" class="headerlink" title="2.2 结构体flock"></a>2.2 结构体<code>flock</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">short</span> l_type;<br>    <span class="hljs-type">short</span> l_whence;<br>    <span class="hljs-type">off_t</span> l_start;<br>    <span class="hljs-type">off_t</span> l_len;<br>    <span class="hljs-type">pid_t</span> l_pid;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-1-成员l-type"><a href="#2-2-1-成员l-type" class="headerlink" title="2.2.1 成员l_type"></a>2.2.1 成员<code>l_type</code></h4><p>锁类型</p><ul><li><code>F_RDLCK</code> ：读锁（共享）</li><li><code>F_WRLCK</code>：写锁（独占）</li><li><code>F_UNLCK</code>：解锁</li></ul><h4 id="2-2-2-成员l-whence"><a href="#2-2-2-成员l-whence" class="headerlink" title="2.2.2 成员l_whence"></a>2.2.2 成员<code>l_whence</code></h4><p>锁的起始位置</p><ul><li><code>SEEK_SET</code> ：文件开头</li><li><code>SEEK_CUR</code>：当前位置</li><li><code>SEEK_END</code>：文件末尾</li></ul><h4 id="2-2-3-成员l-start"><a href="#2-2-3-成员l-start" class="headerlink" title="2.2.3 成员l_start"></a>2.2.3 成员<code>l_start</code></h4><p>锁的起始偏移量，相对于 <code>l_whence</code> 而言</p><h4 id="2-2-4-成员l-len"><a href="#2-2-4-成员l-len" class="headerlink" title="2.2.4 成员l_len"></a>2.2.4 成员<code>l_len</code></h4><p>锁定的字节数</p><h4 id="2-2-5-成员l-pid"><a href="#2-2-5-成员l-pid" class="headerlink" title="2.2.5 成员l_pid"></a>2.2.5 成员<code>l_pid</code></h4><p>仅在<code>fcntl</code>函数执行<code>F_GETLK</code>操作时使用，表示拥有锁的进程ID</p><h3 id="2-3-fcntl函数"><a href="#2-3-fcntl函数" class="headerlink" title="2.3 fcntl函数"></a>2.3 <code>fcntl</code>函数</h3><h4 id="2-3-1-函数原型"><a href="#2-3-1-函数原型" class="headerlink" title="2.3.1 函数原型"></a>2.3.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 失败返回-1，并设置errno</span><br><span class="hljs-comment">// 成功调用，其返回值与操作命令有关</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* optional argument */</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-参数cmd"><a href="#2-3-2-参数cmd" class="headerlink" title="2.3.2 参数cmd"></a>2.3.2 参数<code>cmd</code></h4><ul><li><p><code>F_DUPFD</code>：复制文件描述符</p></li><li><p><code>F_GETFD</code>和<code>F_SETFD</code>：获取&#x2F;设置文件描述符标志<em>（现在只有一个<code>FD_CLOEXEC</code>）</em></p></li><li><p><code>F_GETFL</code>和<code>F_SETFL</code>：获取&#x2F;设置文件状态标志</p></li></ul><table><thead><tr><th align="center">文件状态标志</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>O_APPEND</code></td><td align="center">追加写</td></tr><tr><td align="center"><code>O_NONBLOCK</code></td><td align="center">非阻塞</td></tr><tr><td align="center"><code>O_SYNC</code></td><td align="center">等待写完成（数据和属性）</td></tr><tr><td align="center"><code>O_DSYNC</code></td><td align="center">等待写完成（仅数据）</td></tr><tr><td align="center"><code>O_RSYNC</code></td><td align="center">同步读写</td></tr></tbody></table><ul><li><code>F_GETLK</code>和<code>F_SETLK</code>：获取&#x2F;设置文件锁</li><li><code>F_SETLKW</code>：设置文件锁并等待</li><li><code>F_GETOWN</code>和<code>F_SETOWN</code>：获取&#x2F;设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID</li></ul><h3 id="2-4-锁的隐含继承与释放"><a href="#2-4-锁的隐含继承与释放" class="headerlink" title="2.4 锁的隐含继承与释放"></a>2.4 锁的隐含继承与释放</h3><ul><li><p>进程终止时释放所建立的全部锁</p></li><li><p>关闭一个文件描述符时，该进程通过此描述符所引用的文件上的所有的锁都会被释放</p></li><li><p>子进程<strong>不继承</strong>父进程的锁<em>（若可以继承，则违背了锁的原则）</em></p></li><li><p>在<code>exec</code>后，新程序可以继承原进程的锁，但关闭带有<code>close-on-exec</code>标志的文件描述符会释放所有锁</p></li></ul><h3 id="2-5-文件尾端加锁"><a href="#2-5-文件尾端加锁" class="headerlink" title="2.5 文件尾端加锁"></a>2.5 文件尾端加锁</h3><p>注意：</p><ul><li>当<code>l_len</code>为0时，锁的范围将扩展到最大偏移量。这意味着无论向文件中追加多少数据，这些数据都会被锁定</li><li>在解锁时，<code>SEEK_END</code>的位置可能已经发生变化</li></ul><h3 id="2-6-建议性锁和强制性锁"><a href="#2-6-建议性锁和强制性锁" class="headerlink" title="2.6 建议性锁和强制性锁"></a>2.6 建议性锁和强制性锁</h3><ul><li>建议性锁：进程主动检查并尊重锁，但不强制</li><li>强制性锁：内核执行锁，阻止违规访问</li></ul><h2 id="3-STREAMS"><a href="#3-STREAMS" class="headerlink" title="3. STREAMS"></a>3. STREAMS</h2><h3 id="3-1-概念-1"><a href="#3-1-概念-1" class="headerlink" title="3.1 概念[1]"></a>3.1 概念<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.ibm.com/docs/zh/aix/7.3?topic=streams-introduction">[1]</span></a></sup></h3><blockquote><ul><li>流：内核空间中的驱动程序与用户空间中的进程之间的<strong>全双工</strong>处理和数据传输路径</li><li>STREAMS：用于开发系统通信服务的设施和工具集，允许创建、使用和拆解流</li></ul></blockquote><h3 id="3-2-组成-1"><a href="#3-2-组成-1" class="headerlink" title="3.2 组成[1]"></a>3.2 组成<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.ibm.com/docs/zh/aix/7.3?topic=streams-introduction">[1]</span></a></sup></h3><blockquote><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">流首</td><td align="center">提供流和用户进程之间的接口。它的主要功能是处理STREAMS相关的用户系统调用</td></tr><tr><td align="center">模块</td><td align="center">处理在流首和驱动程序之间传输的数据。模块是可选的</td></tr><tr><td align="center">流尾</td><td align="center">提供外部输入&#x2F;输出设备或内部软件驱动程序的服务。内部软件驱动程序通常称为伪设备驱动程序</td></tr></tbody></table></blockquote><blockquote><p><img src="/2023/10/30/apue-ch14/streams.jpg"></p></blockquote><h3 id="3-3-STREAMS消息"><a href="#3-3-STREAMS消息" class="headerlink" title="3.3 STREAMS消息"></a>3.3 STREAMS消息</h3><p>STREAMS的所有输入和输出都基于消息</p><h4 id="3-3-1-消息组成—类型"><a href="#3-3-1-消息组成—类型" class="headerlink" title="3.3.1 消息组成—类型"></a>3.3.1 消息组成—类型</h4><p><code>read</code>、<code>write</code>、<code>getmsg</code>、<code>getpmsg</code>、<code>putmsg</code>、<code>putpmsg</code>中只涉及到三种消息类型：</p><ul><li><code>M_DATA</code>：I&#x2F;O用户数据</li><li><code>M_PROTO</code>：协议控制信息</li><li><code>M_PCPROTO</code>：高优先级协议控制信息</li></ul><h4 id="3-3-2-消息组成—控制信息和数据（可选）"><a href="#3-3-2-消息组成—控制信息和数据（可选）" class="headerlink" title="3.3.2 消息组成—控制信息和数据（可选）"></a>3.3.2 消息组成—控制信息和数据<em>（可选）</em></h4><p>由<code>strbuf</code>结构指定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">strbuf</span> &#123;</span><br>    <span class="hljs-type">int</span> maxlen;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span>* buf;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>maxlen</code>表示缓冲区长度<em>（以字节为单位）</em>，<code>len</code>为数据量</li><li><code>len</code>可以为0，如果为-1则表示没有控制信息或数据</li></ul><h4 id="3-3-3-消息优先级"><a href="#3-3-3-消息优先级" class="headerlink" title="3.3.3 消息优先级"></a>3.3.3 消息优先级</h4><p>流中的消息的排队优先级</p><ul><li>高优先级消息<em>（最高优先级）</em></li><li>优先级波段消息<em>（波段为1-255，波段愈高，优先级愈高）</em></li><li>普通消息<em>（波段为0，最低优先级）</em></li></ul><h3 id="3-4-putmsg和putpmsg函数-2"><a href="#3-4-putmsg和putpmsg函数-2" class="headerlink" title="3.4 putmsg和putpmsg函数[2]"></a>3.4 <code>putmsg</code>和<code>putpmsg</code>函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.ibm.com/docs/zh/zos/2.2.0?topic=lf-getmsg-getpmsg-receive-next-message-from-streams-file">[2]</span></a></sup></h3><h4 id="3-4-1-功能"><a href="#3-4-1-功能" class="headerlink" title="3.4.1 功能"></a>3.4.1 功能</h4><p>将STREAMS消息写至流中</p><h4 id="3-4-2-函数原型"><a href="#3-4-2-函数原型" class="headerlink" title="3.4.2 函数原型"></a>3.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stropts.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> strbuf *ctlptr, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> strbuf *dataptr, <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">putpmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> strbuf *ctlptr, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> strbuf *dataptr, <span class="hljs-type">int</span> band, <span class="hljs-type">int</span> flag)</span>;<br></code></pre></td></tr></table></figure><h4 id="3-4-3-注意"><a href="#3-4-3-注意" class="headerlink" title="3.4.3 注意"></a>3.4.3 注意</h4><p>对流也可以使用<code>write</code>函数，等价于不带控制信息、<code>flag</code>为0的<code>putmsg</code>函数</p><h3 id="3-5-STREAMSioctl操作"><a href="#3-5-STREAMSioctl操作" class="headerlink" title="3.5 STREAMSioctl操作"></a>3.5 STREAMS<code>ioctl</code>操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-comment">// 出错返回-1，成功返回其他值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> request, ...)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-6-写模式"><a href="#3-6-写模式" class="headerlink" title="3.6 写模式"></a>3.6 写模式</h3><p>使用<code>ioctl</code>函数获得和设置一个流的写模式。如同处理文件描述符标志和文件状态标志，应当先获得当前写模式值，然后再修改</p><h4 id="3-6-1-获得写模式"><a href="#3-6-1-获得写模式" class="headerlink" title="3.6.1 获得写模式"></a>3.6.1 获得写模式</h4><ul><li>参数<code>request</code>为<code>I_GWROPT</code></li><li>第三个参数：指向整型变量的指针</li></ul><h4 id="3-6-2-设置写模式"><a href="#3-6-2-设置写模式" class="headerlink" title="3.6.2 设置写模式"></a>3.6.2 设置写模式</h4><ul><li><p>参数<code>request</code>为<code>I_SWROPT</code></p></li><li><p>第三个参数：整型值</p><ul><li><code>SNDZERO</code>：对管道和FIFO的零长度写会发送零长度消息<em>（默认零长度写不发送消息）</em></li></ul><ul><li><code>SNDPIPE</code>：流错误后，<code>write</code>或<code>putmsg</code>调用会触发<code>SIGPIPE</code>信号</li></ul></li></ul><h3 id="3-7-getmsg和getpmsg函数"><a href="#3-7-getmsg和getpmsg函数" class="headerlink" title="3.7 getmsg和getpmsg函数"></a>3.7 <code>getmsg</code>和<code>getpmsg</code>函数</h3><h4 id="3-7-1-功能"><a href="#3-7-1-功能" class="headerlink" title="3.7.1 功能"></a>3.7.1 功能</h4><p>从流首读STREAMS消息</p><h4 id="3-7-2-函数原型"><a href="#3-7-2-函数原型" class="headerlink" title="3.7.2 函数原型"></a>3.7.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stropts.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回非负值，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> strbuf *<span class="hljs-keyword">restrict</span> ctlptr, <span class="hljs-keyword">struct</span> strbuf *<span class="hljs-keyword">restrict</span> dataptr, <span class="hljs-type">int</span> *<span class="hljs-keyword">restrict</span> flagptr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getpmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> strbuf *<span class="hljs-keyword">restrict</span> ctlptr, <span class="hljs-keyword">struct</span> strbuf *<span class="hljs-keyword">restrict</span> dataptr, <span class="hljs-type">int</span> *<span class="hljs-keyword">restrict</span> bandptr,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> *<span class="hljs-keyword">restrict</span> flagptr)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-8-读模式"><a href="#3-8-读模式" class="headerlink" title="3.8 读模式"></a>3.8 读模式</h3><p>使用<code>ioctl</code>函数获得和设置一个流的读模式。如同处理文件描述符标志和文件状态标志，应当先获得当前读模式值，然后再修改</p><h4 id="3-8-1-获得读模式"><a href="#3-8-1-获得读模式" class="headerlink" title="3.8.1 获得读模式"></a>3.8.1 获得读模式</h4><ul><li>参数<code>request</code>为<code>I_GRDOPT</code></li><li>第三个参数：指向整型变量的指针</li></ul><h4 id="3-8-2-设置读模式"><a href="#3-8-2-设置读模式" class="headerlink" title="3.8.2 设置读模式"></a>3.8.2 设置读模式</h4><ul><li>参数<code>request</code>为<code>I_SRDOPT</code></li><li>第三个参数：整型值<em>（只能设置一种消息读模式和一种协议读模式，默认读模式是<code>RNORM | RPROTNORM</code>）</em><ul><li>消息读模式<ul><li><code>RNORM</code>：普通，字节流模式</li><li><code>RMSGN</code>：消息不丢弃模式</li><li><code>RMSGD</code>：消息丢弃模式</li></ul></li><li>协议读模式<ul><li><code>RPROTNORM</code>：协议-普通模式</li><li><code>RPROTDAT</code>：协议-数据模式</li><li><code>RPROTDIS</code>：协议-丢弃模式</li></ul></li></ul></li></ul><h2 id="4-I-O多路转接"><a href="#4-I-O多路转接" class="headerlink" title="4. I&#x2F;O多路转接"></a>4. I&#x2F;O多路转接</h2><p>I&#x2F;O多路转接允许单个进程同时监视多个I&#x2F;O通道，提高并发性和效率</p><h3 id="4-1-select函数"><a href="#4-1-select函数" class="headerlink" title="4.1 select函数"></a>4.1 <code>select</code>函数</h3><h4 id="4-1-1-功能"><a href="#4-1-1-功能" class="headerlink" title="4.1.1 功能"></a>4.1.1 功能</h4><p><code>select</code>函数监控多个文件描述符，检查其I&#x2F;O状态，可设定超时</p><h4 id="4-1-2-fd-set类型-3"><a href="#4-1-2-fd-set类型-3" class="headerlink" title="4.1.2 fd_set类型[3]"></a>4.1.2 <code>fd_set</code>类型<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/Zorro721/article/details/107565000">[3]</span></a></sup></h4><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-comment">// 简化版本</span><br><span class="hljs-comment">// 源码在/usr/include/sys/select.h下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> fds_bits[<span class="hljs-number">32</span>];<br>&#125; fd_set;<br></code></pre></td></tr></table></figure></blockquote><p>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br>FD_ZERO(fd_set *<span class="hljs-built_in">set</span>);          <span class="hljs-comment">// 将set清零使集合中不含任何fd</span><br>FD_SET(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>);   <span class="hljs-comment">// 将fd加入set集合</span><br>FD_CLR(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>);   <span class="hljs-comment">// 将fd从set集合中清除</span><br>FD_ISSET(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>); <span class="hljs-comment">// 检测fd是否在set集合中，不在则返回0</span><br></code></pre></td></tr></table></figure><p>操作示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">fd_set rset;<br><span class="hljs-type">int</span> fd;<br><br>FD_ZERO(&amp;rset);<br>FD_SET(fd, &amp;rset);<br>FD_SET(STDIN_FILENO, &amp;rset);<br><br><span class="hljs-comment">// 从select返回后，判断其是否仍在集合中</span><br><span class="hljs-keyword">if</span> (FD_ISSET(fd, &amp;rset))<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-结构体timeval"><a href="#4-1-3-结构体timeval" class="headerlink" title="4.1.3 结构体timeval"></a>4.1.3 结构体<code>timeval</code></h4><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>       <span class="hljs-type">long</span> tv_sec;  <span class="hljs-comment">/* seconds */</span><br>       <span class="hljs-type">long</span> tv_usec; <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4-1-4-函数原型"><a href="#4-1-4-函数原型" class="headerlink" title="4.1.4 函数原型"></a>4.1.4 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-comment">// 返回准备就绪的描述符数，超时返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> maxfdp1, fd_set *<span class="hljs-keyword">restrict</span> readfds, fd_set *<span class="hljs-keyword">restrict</span> writefds, fd_set *<span class="hljs-keyword">restrict</span> exceptfds,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval *<span class="hljs-keyword">restrict</span> tvptr)</span>;<br></code></pre></td></tr></table></figure><h4 id="4-1-5-参数"><a href="#4-1-5-参数" class="headerlink" title="4.1.5 参数"></a>4.1.5 参数</h4><ul><li><code>maxfdp1</code>：在三个描述符集中找出最大描述符编号值，然后加1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">fd_set readset writeset;<br><br>FD_ZERO(&amp;readset);<br>FD_ZERO(&amp;writeset);<br>FD_SET(<span class="hljs-number">0</span>, &amp;readset);<br>FD_SET(<span class="hljs-number">3</span>, &amp;readset);<br>FD_SET(<span class="hljs-number">1</span>, &amp;writeset);<br>FD_SET(<span class="hljs-number">2</span>, &amp;writeset);<br><br>select(<span class="hljs-number">4</span>, &amp;readset, &amp;writeset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p><img src="/2023/10/30/apue-ch14/maxfdp.png" alt="select的示例描述符集"></p><ul><li>参数<code>readfds</code>：读集</li><li>参数<code>writefds</code>：写集</li><li>参数<code>exceptfds</code>：异常状态集</li><li>参数<code>tvptr</code>：指定等待时间，有三种情况<ul><li><code>tvptr == NULL</code>：一直等待，直到至少有一个文件描述符准备好</li><li><code>tvptr-&gt;tv_sec == 0 &amp;&amp; tvptr-&gt;tv_usec == 0</code>：完全不等待，测试完所有描述符并立即返回</li><li><code>tvptr-&gt;tv_sec != 0 || tvptr-&gt;tv_usec != 0</code>：等待指定的秒数和微妙数。当某一描述符准备好或者超时，立即返回</li></ul></li></ul><h4 id="4-1-6-注意"><a href="#4-1-6-注意" class="headerlink" title="4.1.6 注意"></a>4.1.6 注意</h4><ul><li><p>文件描述符的阻塞状态与<code>select</code>函数是否阻塞无关</p></li><li><p>当文件描述符读取到文件结尾时，<code>select</code>函数会将其视为可读状态，而非异常状态</p></li></ul><h3 id="4-2-pselect函数"><a href="#4-2-pselect函数" class="headerlink" title="4.2 pselect函数"></a>4.2 <code>pselect</code>函数</h3><h4 id="4-2-1-功能"><a href="#4-2-1-功能" class="headerlink" title="4.2.1 功能"></a>4.2.1 功能</h4><p>监视多个文件描述符，支持纳秒级超时和信号掩码设置</p><h4 id="4-2-2-结构体timespec"><a href="#4-2-2-结构体timespec" class="headerlink" title="4.2.2 结构体timespec"></a>4.2.2 结构体<code>timespec</code></h4><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span></span><br><span class="hljs-class">&#123;</span><br>       <span class="hljs-type">time_t</span> tv_sec; <span class="hljs-comment">/* Seconds */</span><br>       <span class="hljs-type">long</span> tv_nsec;  <span class="hljs-comment">/* Nanoseconds */</span><br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4-2-3-函数原型"><a href="#4-2-3-函数原型" class="headerlink" title="4.2.3 函数原型"></a>4.2.3 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-comment">// 返回准备就绪的描述符数，超时返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pselect</span><span class="hljs-params">(<span class="hljs-type">int</span> maxfdp1, fd_set *<span class="hljs-keyword">restrict</span> readfds, fd_set *<span class="hljs-keyword">restrict</span> writefds, fd_set *<span class="hljs-keyword">restrict</span> exceptfds,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> tsptr, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-keyword">restrict</span> sigmask)</span>;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-sigset-t类型及操作"><a href="#4-2-4-sigset-t类型及操作" class="headerlink" title="4.2.4 sigset_t类型及操作"></a>4.2.4 <code>sigset_t</code>类型及操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* /usr/include/signal.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">__sigset_t</span> <span class="hljs-type">sigset_t</span>;<br><br><span class="hljs-comment">/* /usr/include/bits/sigset.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125; <span class="hljs-type">__sigset_t</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-comment">// 初始化由set指定的信号集，信号集里面的所有信号被清空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><br><span class="hljs-comment">// 调用该函数后，set指向的信号集中将包含linux支持的64种信号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><br><span class="hljs-comment">// 在set指向的信号集中加入signum信号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><br><span class="hljs-comment">// 在set指向的信号集中删除signum信号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><br><span class="hljs-comment">// 判定信号signum是否在set指向的信号集中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br></code></pre></td></tr></table></figure><h4 id="4-2-5-参数sigmask"><a href="#4-2-5-参数sigmask" class="headerlink" title="4.2.5 参数sigmask"></a>4.2.5 参数<code>sigmask</code></h4><p><code>sigmask</code>参数在<code>pselect</code>函数中用于在调用<code>pselect</code>期间原子性地阻塞某些信号</p><ul><li>如果<code>sigmask</code>为空，那么在处理信号方面，<code>pselect</code>和<code>select</code>的行为是相同的</li><li>如果<code>sigmask</code>不为空，那么在调用<code>pselect</code>时，会以原子操作的方式应用这个信号掩码，并在返回时恢复之前的信号掩码</li></ul><h4 id="4-2-6-注意"><a href="#4-2-6-注意" class="headerlink" title="4.2.6 注意"></a>4.2.6 注意</h4><p><code>pselect</code>不会修改时间参数</p><h3 id="4-3-poll函数"><a href="#4-3-poll函数" class="headerlink" title="4.3 poll函数"></a>4.3 <code>poll</code>函数</h3><h4 id="4-3-1-功能"><a href="#4-3-1-功能" class="headerlink" title="4.3.1 功能"></a>4.3.1 功能</h4><p>功能类似于<code>select</code>函数，监视文件描述符状态变化</p><h4 id="4-3-2-结构体pollfd"><a href="#4-3-2-结构体pollfd" class="headerlink" title="4.3.2 结构体pollfd"></a>4.3.2 结构体<code>pollfd</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;        <span class="hljs-comment">/* file descriptor to check, or &lt;0 to ignore */</span><br>    <span class="hljs-type">short</span> events;  <span class="hljs-comment">/* events of interest on fd */</span><br>    <span class="hljs-type">short</span> revents; <span class="hljs-comment">/* events that occurred on fd */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-3-3-events和revents-4"><a href="#4-3-3-events和revents-4" class="headerlink" title="4.3.3 events和revents[4]"></a>4.3.3 <code>events</code>和<code>revents</code><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/skypeng57/article/details/82743681">[4]</span></a></sup></h4><table><thead><tr><th align="center">事件</th><th align="center">值</th><th align="center">是否可作为<code>events</code></th><th align="center">是否可作为<code>revents</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">读</td><td align="center"><code>POLLIN</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可读除高优先级外的数据（等价于&#96;POLLRDNORM</td></tr><tr><td align="center">读</td><td align="center"><code>POLLRDNORM</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可读普通数据（优先级波段为0）</td></tr><tr><td align="center">读</td><td align="center"><code>POLLRDBAND</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可读非0优先级波段数据</td></tr><tr><td align="center">读</td><td align="center"><code>POLLPRI</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可读高优先级数据</td></tr><tr><td align="center">写</td><td align="center"><code>POLLOUT</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可写普通数据</td></tr><tr><td align="center">写</td><td align="center"><code>POLLWRNORM</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">与<code>POLLOUT</code>相同</td></tr><tr><td align="center">写</td><td align="center"><code>POLLWRBAND</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">不阻塞地可写非0优先级波段数据</td></tr><tr><td align="center">异常</td><td align="center"><code>POLLERR</code></td><td align="center">&#10006;</td><td align="center">&#10004;</td><td align="center">已出错</td></tr><tr><td align="center">异常</td><td align="center"><code>POLLHUP</code></td><td align="center">&#10006;</td><td align="center">&#10004;</td><td align="center">已挂起</td></tr><tr><td align="center">异常</td><td align="center"><code>POLLNVAL</code></td><td align="center">&#10006;</td><td align="center">&#10004;</td><td align="center">描述符不引用打开文件</td></tr></tbody></table><h4 id="4-3-4-函数原型"><a href="#4-3-4-函数原型" class="headerlink" title="4.3.4 函数原型"></a>4.3.4 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-comment">// 返回准备就绪的描述符数，超时返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd fdarray[], <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure><h4 id="4-3-5-参数nfds"><a href="#4-3-5-参数nfds" class="headerlink" title="4.3.5 参数nfds"></a>4.3.5 参数<code>nfds</code></h4><p><code>fdarray</code>长度</p><h4 id="4-3-6-参数timeout"><a href="#4-3-6-参数timeout" class="headerlink" title="4.3.6 参数timeout"></a>4.3.6 参数<code>timeout</code></h4><table><thead><tr><th align="center"><code>timeout</code>值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">永远等待</td></tr><tr><td align="center">0</td><td align="center">不等待，测试所有描述符后立即返回</td></tr><tr><td align="center">正数</td><td align="center">等待<code>timeout</code>毫秒</td></tr></tbody></table><h2 id="5-readv和writev函数"><a href="#5-readv和writev函数" class="headerlink" title="5. readv和writev函数"></a>5. <code>readv</code>和<code>writev</code>函数</h2><h3 id="5-1-功能"><a href="#5-1-功能" class="headerlink" title="5.1 功能"></a>5.1 功能</h3><p><code>readv</code>实现分散读，<code>writev</code>实现集中写，提高IO效率<em>（v代表vector）</em></p><h3 id="5-2-结构体iovec"><a href="#5-2-结构体iovec" class="headerlink" title="5.2 结构体iovec"></a>5.2 结构体<code>iovec</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> *iov_base; <span class="hljs-comment">/* starting address of buffer */</span><br>    <span class="hljs-type">size_t</span> iov_len; <span class="hljs-comment">/* size of buffer */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-3-函数原型"><a href="#5-3-函数原型" class="headerlink" title="5.3 函数原型"></a>5.3 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回已读写的字符数，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-4-readv和writev的iovec结构"><a href="#5-4-readv和writev的iovec结构" class="headerlink" title="5.4 readv和writev的iovec结构"></a>5.4 <code>readv</code>和<code>writev</code>的<code>iovec</code>结构</h3><p><img src="/2023/10/30/apue-ch14/iovec.png" alt="readv和writev的iovec结构"></p><h2 id="6-存储映射I-O"><a href="#6-存储映射I-O" class="headerlink" title="6. 存储映射I&#x2F;O"></a>6. 存储映射I&#x2F;O</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><p>将磁盘文件与缓冲区关联，使得读缓冲区等同于读文件，写缓冲区等同于写文件</p><h3 id="6-2-mmap函数"><a href="#6-2-mmap函数" class="headerlink" title="6.2 mmap函数"></a>6.2 <code>mmap</code>函数</h3><h4 id="6-2-1-功能"><a href="#6-2-1-功能" class="headerlink" title="6.2.1 功能"></a>6.2.1 功能</h4><p>将文件映射到内存</p><h4 id="6-2-2-函数原型"><a href="#6-2-2-函数原型" class="headerlink" title="6.2.2 函数原型"></a>6.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回映射区的起始地址，出错返回MAP_FAILED</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> off)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-3-参数"><a href="#6-2-3-参数" class="headerlink" title="6.2.3 参数"></a>6.2.3 参数</h4><ul><li><code>addr</code>：映射区的起始地址。通常设置为0，表示由系统选择</li><li><code>len</code>：映射区长度</li><li><code>prot</code>：映射区保护模式。它可以设为<code>PROT_NONE</code>，或者是<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code>任一组合的按位或。映射区的保护级别不能超过文件的打开权限。例如，如果文件是只读的，那么映射区就不能设为<code>PROT_WRITE</code></li></ul><table><thead><tr><th align="center"><code>prot</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>PROT_READ</code></td><td align="center">映射区可读</td></tr><tr><td align="center"><code>PROT_WRITE</code></td><td align="center">映射区可写</td></tr><tr><td align="center"><code>PROT_EXEC</code></td><td align="center">映射区可执行</td></tr><tr><td align="center"><code>PROT_NONE</code></td><td align="center">映射区不可访问</td></tr></tbody></table><ul><li><code>flag</code>：映射标志</li></ul><table><thead><tr><th align="center"><code>flag</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>MAP_FIXED</code></td><td align="center">返回值必须等于<code>addr</code><em>（不鼓励使用，因为其可移植性比较差）</em></td></tr><tr><td align="center"><code>MAP_SHARED</code></td><td align="center">多个进程可共享映射，对映射的更改在不同进程间可见，且更改写回原文件</td></tr><tr><td align="center"><code>MAP_PRIVATE</code></td><td align="center">对映射区的修改不会写回原文件，对其他进程不可见</td></tr></tbody></table><ul><li><code>fd</code>：待映射的文件描述符</li><li><code>off</code>：待映射的文件偏移量</li></ul><p><img src="/2023/10/30/apue-ch14/mmap.png" alt="mmap函数效果"></p><h3 id="6-3-mprotect函数"><a href="#6-3-mprotect函数" class="headerlink" title="6.3 mprotect函数"></a>6.3 <code>mprotect</code>函数</h3><h4 id="6-3-1-功能"><a href="#6-3-1-功能" class="headerlink" title="6.3.1 功能"></a>6.3.1 功能</h4><p>更改映射区权限</p><h4 id="6-3-2-函数原型"><a href="#6-3-2-函数原型" class="headerlink" title="6.3.2 函数原型"></a>6.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-3-参数prot"><a href="#6-3-3-参数prot" class="headerlink" title="6.3.3 参数prot"></a>6.3.3 参数<code>prot</code></h4><p>同<code>mmap</code>函数参数<code>prot</code></p><h3 id="6-4-msync函数"><a href="#6-4-msync函数" class="headerlink" title="6.4 msync函数"></a>6.4 <code>msync</code>函数</h3><h4 id="6-4-1-功能"><a href="#6-4-1-功能" class="headerlink" title="6.4.1 功能"></a>6.4.1 功能</h4><p>将映射区域的修改同步到对应的文件中</p><h4 id="6-4-2-函数原型"><a href="#6-4-2-函数原型" class="headerlink" title="6.4.2 函数原型"></a>6.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msync</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-4-3-参数flags"><a href="#6-4-3-参数flags" class="headerlink" title="6.4.3 参数flags"></a>6.4.3 参数<code>flags</code></h4><ul><li><code>MS_ASYNC</code>：异步写入</li><li><code>MS_SYNC</code>：同步写入<em>（一直等待将数据同步写入磁盘）</em></li><li><code>MS_INVALIDATE</code>：使内存区域无效</li></ul><h3 id="6-5-munmap函数"><a href="#6-5-munmap函数" class="headerlink" title="6.5 munmap函数"></a>6.5 <code>munmap</code>函数</h3><h4 id="6-5-1-功能"><a href="#6-5-1-功能" class="headerlink" title="6.5.1 功能"></a>6.5.1 功能</h4><p>解除映射</p><h4 id="6-5-2-函数原型"><a href="#6-5-2-函数原型" class="headerlink" title="6.5.2 函数原型"></a>6.5.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">caddr_t</span> addr, <span class="hljs-type">size_t</span> len)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-5-3-注意"><a href="#6-5-3-注意" class="headerlink" title="6.5.3 注意"></a>6.5.3 注意</h4><ul><li>关闭文件描述符不解除映射区</li><li>进程终止也会解除映射区</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.ibm.com/docs/zh/aix/7.3?topic=streams-introduction">https://www.ibm.com/docs/zh/aix/7.3?topic=streams-introduction</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.ibm.com/docs/zh/zos/2.2.0?topic=lf-getmsg-getpmsg-receive-next-message-from-streams-file">https://www.ibm.com/docs/zh/zos/2.2.0?topic=lf-getmsg-getpmsg-receive-next-message-from-streams-file</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/Zorro721/article/details/107565000">https://blog.csdn.net/Zorro721/article/details/107565000</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/skypeng57/article/details/82743681">https://blog.csdn.net/skypeng57/article/details/82743681</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 05 - Standard I/O Library</title>
    <link href="/2023/10/25/apue-ch05/"/>
    <url>/2023/10/25/apue-ch05/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-05-标准I-O库"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-05-标准I-O库" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 05 标准I&#x2F;O库"></a>Advanced Programming in the UNIX Environment—Chapter 05 标准I&#x2F;O库</h1><h2 id="1-流的定向"><a href="#1-流的定向" class="headerlink" title="1. 流的定向"></a>1. 流的定向</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>流的定向决定了读写的字符是单字节还是多字节。<strong>流最初被创建时，没有定向</strong></p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><ul><li>宽定向：多字节</li><li>字节定向：单字节</li></ul><h3 id="1-3-fwide函数"><a href="#1-3-fwide函数" class="headerlink" title="1.3 fwide函数"></a>1.3 <code>fwide</code>函数</h3><h4 id="1-3-1-功能"><a href="#1-3-1-功能" class="headerlink" title="1.3.1 功能"></a>1.3.1 功能</h4><p><strong>设置</strong>或<strong>查询</strong>流的定向属性</p><h4 id="1-3-2-函数原型"><a href="#1-3-2-函数原型" class="headerlink" title="1.3.2 函数原型"></a>1.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wchar.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 流是宽定向的返回正值</span><br><span class="hljs-comment"> * 流是字节定向的返回负值</span><br><span class="hljs-comment"> * 流未定向返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fwide</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">int</span> mode)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-参数mode"><a href="#1-3-3-参数mode" class="headerlink" title="1.3.3 参数mode"></a>1.3.3 参数<code>mode</code></h4><ul><li><code>mode</code>为正，指定流为宽定向</li><li><code>mode</code>为零，不试图设置流的定向，但返回流定向的值</li><li><code>mode</code>为负，指定流为字节定向</li></ul><h4 id="1-3-4-注意"><a href="#1-3-4-注意" class="headerlink" title="1.3.4 注意"></a>1.3.4 注意</h4><ul><li><code>fwide</code>不改变<strong>已定向</strong>的流</li><li><code>fwide</code>无出错返回</li></ul><h2 id="2-缓冲"><a href="#2-缓冲" class="headerlink" title="2. 缓冲"></a>2. 缓冲</h2><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><ul><li><p>全缓冲：缓冲区填满后才进行实际I&#x2F;O操作。<em>一个流上执行第一次I&#x2F;O操作时，相关标准I&#x2F;O函数通常调用<code>malloc</code>获得所需要的缓冲区</em></p></li><li><p>行缓冲：遇到换行符执行I&#x2F;O操作。流涉及到终端（例如标准输入和标准输出）时，通常使用行缓冲</p></li><li><p>不缓冲：不对字符进行缓冲存储。<code>stderr</code>通常不带缓冲</p></li></ul><h3 id="2-2-更改缓冲类型"><a href="#2-2-更改缓冲类型" class="headerlink" title="2.2 更改缓冲类型"></a>2.2 更改缓冲类型</h3><h4 id="2-2-1-函数原型"><a href="#2-2-1-函数原型" class="headerlink" title="2.2.1 函数原型"></a>2.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setbuf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf)</span>;<br><span class="hljs-comment">// 成功返回0，出错返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-参数mode"><a href="#2-2-2-参数mode" class="headerlink" title="2.2.2 参数mode"></a>2.2.2 参数<code>mode</code></h4><ul><li><code>_IOFBF</code>：全缓冲</li><li><code>_IOLBF</code>：行缓冲</li><li><code>_IONBF</code>：不带缓冲</li></ul><h4 id="2-2-3-搭配不同参数时的效果"><a href="#2-2-3-搭配不同参数时的效果" class="headerlink" title="2.2.3 搭配不同参数时的效果"></a>2.2.3 搭配不同参数时的效果</h4><p><img src="/2023/10/25/apue-ch05/setbuf_setvbuf.png" alt="setbuf和setvbuf函数"></p><h3 id="2-3-冲洗（flush）"><a href="#2-3-冲洗（flush）" class="headerlink" title="2.3 冲洗（flush）"></a>2.3 冲洗（flush）</h3><h4 id="2-3-1-含义"><a href="#2-3-1-含义" class="headerlink" title="2.3.1 含义"></a>2.3.1 含义</h4><ul><li>标准I&#x2F;O库方面，flush将缓冲区内容写到磁盘上</li><li>终端驱动程序方面，flush表示丢弃缓冲区中的数据</li></ul><h4 id="2-3-2-fflush函数"><a href="#2-3-2-fflush函数" class="headerlink" title="2.3.2 fflush函数"></a>2.3.2 <code>fflush</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-打开流"><a href="#3-打开流" class="headerlink" title="3. 打开流"></a>3. 打开流</h2><h3 id="3-1-函数原型"><a href="#3-1-函数原型" class="headerlink" title="3.1 函数原型"></a>3.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回文件指针，出错返回NULL</span><br>FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> type)</span>;<br>FILE *<span class="hljs-title function_">freopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> type, FILE *<span class="hljs-keyword">restrict</span> fp)</span>;<br>FILE *<span class="hljs-title function_">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-功能"><a href="#3-2-功能" class="headerlink" title="3.2 功能"></a>3.2 功能</h3><ul><li><code>fopen</code>：打开一个指定的文件</li><li><code>freopen</code>：在一个指定的流上打开一个指定的文件</li><li><code>fdopen</code>：将一个已存在的文件描述符与一个流关联起来</li></ul><h3 id="3-3-参数type"><a href="#3-3-参数type" class="headerlink" title="3.3 参数type"></a>3.3 参数<code>type</code></h3><table><thead><tr><th align="center"><code>type</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>r</code>或<code>rb</code></td><td align="center">读打开</td></tr><tr><td align="center"><code>w</code>或<code>wb</code></td><td align="center">文件首写打开，或为写创建</td></tr><tr><td align="center"><code>a</code>或<code>ab</code></td><td align="center">文件尾写打开，或为写创建</td></tr><tr><td align="center"><code>r</code>或<code>r+b</code>或<code>rb+</code></td><td align="center">读写打开</td></tr><tr><td align="center"><code>w</code>或<code>w+b</code>或<code>wb+</code></td><td align="center">文件首读写打开，或为读写创建</td></tr><tr><td align="center"><code>a+</code>或<code>a+b</code>或<code>ab+</code></td><td align="center">文件尾读写打开，或为读写创建</td></tr></tbody></table><h2 id="4-关闭流"><a href="#4-关闭流" class="headerlink" title="4. 关闭流"></a>4. 关闭流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h2 id="5-读流和写流"><a href="#5-读流和写流" class="headerlink" title="5. 读流和写流"></a>5. 读流和写流</h2><h3 id="5-1-输入"><a href="#5-1-输入" class="headerlink" title="5.1 输入"></a>5.1 输入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回下一个字符，出错或到达文件结尾返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>getchar</code>等效于<code>getc(stdin)</code></li><li><code>getc</code>可以用宏实现，<code>fgetc</code>一定是函数</li></ul><h3 id="5-2-两个标志"><a href="#5-2-两个标志" class="headerlink" title="5.2 两个标志"></a>5.2 两个标志</h3><p>大多数实现中，每个流在FILE对象中维护两个标志</p><ul><li><p>出错标志</p></li><li><p>文件结束标志</p></li></ul><h3 id="5-3-ferror、feof和clearerr函数"><a href="#5-3-ferror、feof和clearerr函数" class="headerlink" title="5.3 ferror、feof和clearerr函数"></a>5.3 <code>ferror</code>、<code>feof</code>和<code>clearerr</code>函数</h3><ul><li><code>ferror</code>函数：检测流是否发生错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 条件为真返回非0值，否则返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ferror</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>feof</code>函数：检测流是否到达文件结束</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 条件为真返回非0值，否则返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">feof</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clearerr</code>函数：清除标志</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clearerr</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-4-ungetc函数"><a href="#5-4-ungetc函数" class="headerlink" title="5.4 ungetc函数"></a>5.4 <code>ungetc</code>函数</h3><h4 id="5-4-1-功能"><a href="#5-4-1-功能" class="headerlink" title="5.4.1 功能"></a>5.4.1 功能</h4><p>将字符推回到输入流中</p><h4 id="5-4-2-函数原型"><a href="#5-4-2-函数原型" class="headerlink" title="5.4.2 函数原型"></a>5.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回c，出错返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ungetc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h4 id="5-4-3-注意"><a href="#5-4-3-注意" class="headerlink" title="5.4.3 注意"></a>5.4.3 注意</h4><ul><li>字符推回流后，读出字符的顺序与压送回的顺序相反</li><li>不能回送<code>EOF</code></li><li>回送的字符不必是上一次读到的字符</li><li>到达文件尾端仍可以回送字符<em>（因为成功的<code>ungetc</code>调用会清除流的文件结束标志）</em></li></ul><h3 id="5-5-输出"><a href="#5-5-输出" class="headerlink" title="5.5 输出"></a>5.5 输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回c，出错返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>putchar(c)</code>等效于<code>putc(c, stdout)</code></li><li><code>putc</code>可以用宏实现，<code>fputc</code>一定是函数</li></ul><h2 id="6-行I-O"><a href="#6-行I-O" class="headerlink" title="6.  行I&#x2F;O"></a>6.  行I&#x2F;O</h2><h3 id="6-1-行输入"><a href="#6-1-行输入" class="headerlink" title="6.1 行输入"></a>6.1 行输入</h3><h4 id="6-1-1-函数原型"><a href="#6-1-1-函数原型" class="headerlink" title="6.1.1 函数原型"></a>6.1.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回buf，到达文件结尾或出错返回NULL</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">int</span> n, FILE *<span class="hljs-keyword">restrict</span> fp)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-注意"><a href="#6-1-2-注意" class="headerlink" title="6.1.2 注意"></a>6.1.2 注意</h4><ul><li><p><code>fgets</code>读取至换行或<code>n</code>-1字符，存入缓冲区并以null结尾。超出部分在下次调用时读取</p></li><li><p><code>gets</code>不推荐使用<em>（可能发生缓冲区溢出）</em>，且不将换行符存入缓冲区中</p></li></ul><h3 id="6-2-行输出"><a href="#6-2-行输出" class="headerlink" title="6.2 行输出"></a>6.2 行输出</h3><h4 id="6-2-1-函数原型"><a href="#6-2-1-函数原型" class="headerlink" title="6.2.1 函数原型"></a>6.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回非负值，出错返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> str, FILE *<span class="hljs-keyword">restrict</span> fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-注意"><a href="#6-2-2-注意" class="headerlink" title="6.2.2 注意"></a>6.2.2 注意</h4><ul><li><code>fputs</code>将字符串写入流，不包括null。不必每次输出一行，null前可无换行符</li><li><code>puts</code>函数将字符串写入标准输出，不包括null，但包括换行符</li></ul><h2 id="7-二进制I-O"><a href="#7-二进制I-O" class="headerlink" title="7. 二进制I&#x2F;O"></a>7. 二进制I&#x2F;O</h2><h3 id="7-1-函数原型"><a href="#7-1-函数原型" class="headerlink" title="7.1 函数原型"></a>7.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 返回值是读或写的对象数</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nobj, FILE *<span class="hljs-keyword">restrict</span> fp)</span>;<br><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nobj, FILE *<span class="hljs-keyword">restrict</span> fp)</span>;<br></code></pre></td></tr></table></figure><h3 id="7-2-使用场景"><a href="#7-2-使用场景" class="headerlink" title="7.2 使用场景"></a>7.2 使用场景</h3><ul><li>读写二进制数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">float</span> data[<span class="hljs-number">10</span>];<br><br>fwrite(&amp;data[<span class="hljs-number">2</span>], <span class="hljs-keyword">sizeof</span>(data[<span class="hljs-number">0</span>]), <span class="hljs-number">4</span>, fp); <span class="hljs-comment">// data[2] data[3] data[4] data[5]</span><br></code></pre></td></tr></table></figure><ul><li>读写一个结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">short</span> count;<br>    <span class="hljs-type">long</span> total;<br>    <span class="hljs-type">char</span> name[NAMESIZE];<br>&#125; item;<br><br>fwrite(&amp;item, <span class="hljs-keyword">sizeof</span>(item), <span class="hljs-number">1</span>, fp);<br></code></pre></td></tr></table></figure><h2 id="8-定位流"><a href="#8-定位流" class="headerlink" title="8. 定位流"></a>8. 定位流</h2><h3 id="8-1-ftell和fseek函数（long）"><a href="#8-1-ftell和fseek函数（long）" class="headerlink" title="8.1 ftell和fseek函数（long）"></a>8.1 <code>ftell</code>和<code>fseek</code>函数（<code>long</code>）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 返回当前文件位置指示，出错返回-1L</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *fp)</span>;<br><br><span class="hljs-comment">// 成功返回0，出错返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-2-ftello和fseeko函数（off-t）"><a href="#8-2-ftello和fseeko函数（off-t）" class="headerlink" title="8.2 ftello和fseeko函数（off_t）"></a>8.2 <code>ftello</code>和<code>fseeko</code>函数（<code>off_t</code>）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回当前文件位置指示，出错返回-1</span><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">ftello</span><span class="hljs-params">(FILE *fp)</span>;<br><br><span class="hljs-comment">// 成功返回0，出错返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fseeko</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-3-fgetpos和fsetpos函数（fpos-t）"><a href="#8-3-fgetpos和fsetpos函数（fpos-t）" class="headerlink" title="8.3 fgetpos和fsetpos函数（fpos_t）"></a>8.3 <code>fgetpos</code>和<code>fsetpos</code>函数（<code>fpos_t</code>）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回非0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetpos</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">fpos_t</span> *<span class="hljs-keyword">restrict</span> pos)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-4-rewind函数"><a href="#8-4-rewind函数" class="headerlink" title="8.4 rewind函数"></a>8.4 <code>rewind</code>函数</h3><p>将文件指针重置到文件开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h2 id="9-格式化I-O"><a href="#9-格式化I-O" class="headerlink" title="9. 格式化I&#x2F;O"></a>9. 格式化I&#x2F;O</h2><h3 id="9-1-格式化输出"><a href="#9-1-格式化输出" class="headerlink" title="9.1 格式化输出"></a>9.1 格式化输出</h3><h4 id="9-1-1-函数原型"><a href="#9-1-1-函数原型" class="headerlink" title="9.1.1 函数原型"></a>9.1.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回输出字符数，出错返回负值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>;<br><br><span class="hljs-comment">// 成功返回存入数组的字符数，编码出错返回负值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>;            <span class="hljs-comment">// 将格式化的数据写入字符串</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">snprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>; <span class="hljs-comment">// 将格式化的数据写入字符串</span><br></code></pre></td></tr></table></figure><h4 id="9-1-2-可变参数arg替换"><a href="#9-1-2-可变参数arg替换" class="headerlink" title="9.1.2 可变参数arg替换..."></a>9.1.2 可变参数<code>arg</code>替换<code>...</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回输出字符数，出错返回负值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">vfprintf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>;<br><br><span class="hljs-comment">// 成功返回存入数组的字符数，编码出错返回负值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>;            <span class="hljs-comment">// 将格式化的数据写入字符串</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vsnprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>; <span class="hljs-comment">// 将格式化的数据写入字符串</span><br></code></pre></td></tr></table></figure><h3 id="9-2-格式化输入"><a href="#9-2-格式化输入" class="headerlink" title="9.2 格式化输入"></a>9.2 格式化输入</h3><h4 id="9-2-1-函数原型"><a href="#9-2-1-函数原型" class="headerlink" title="9.2.1 函数原型"></a>9.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 返回指定的输入项数，若出错或任意变换前到达文件结尾返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, ...)</span>; <span class="hljs-comment">// 从字符串中读取格式化输入</span><br></code></pre></td></tr></table></figure><h4 id="9-2-2-可变参数arg替换"><a href="#9-2-2-可变参数arg替换" class="headerlink" title="9.2.2 可变参数arg替换..."></a>9.2.2 可变参数<code>arg</code>替换<code>...</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-comment">// 返回指定的输入项数，若出错或任意变换前到达文件结尾返回EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">vfscanf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span> fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">vsscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> format, va_list arg)</span>; <span class="hljs-comment">// 从字符串中读取格式化输入</span><br></code></pre></td></tr></table></figure><h2 id="10-获得流对应的描述符"><a href="#10-获得流对应的描述符" class="headerlink" title="10. 获得流对应的描述符"></a>10. 获得流对应的描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 返回与流相关联的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fileno</span><span class="hljs-params">(FILE * fp)</span>;<br></code></pre></td></tr></table></figure><h2 id="11-临时文件"><a href="#11-临时文件" class="headerlink" title="11. 临时文件"></a>11. 临时文件</h2><h3 id="11-1-tmpnam函数"><a href="#11-1-tmpnam函数" class="headerlink" title="11.1 tmpnam函数"></a>11.1 <code>tmpnam</code>函数</h3><h4 id="11-1-1-功能"><a href="#11-1-1-功能" class="headerlink" title="11.1.1 功能"></a>11.1.1 功能</h4><p>生成并返回一个有效的临时文件名</p><h4 id="11-1-2-函数原型"><a href="#11-1-2-函数原型" class="headerlink" title="11.1.2 函数原型"></a>11.1.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 指向唯一路径名的指针</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">tmpnam</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><h4 id="11-1-3-参数ptr"><a href="#11-1-3-参数ptr" class="headerlink" title="11.1.3 参数ptr"></a>11.1.3 参数<code>ptr</code></h4><ul><li>为<code>NULL</code>时，函数返回指向静态区路径名的指针，下次调用将重写此区域</li><li>不为<code>NULL</code>时，<code>ptr</code>指向一个长度至少为<code>L_tmpnam</code><em>（定义在<code>&lt;stdio.h&gt;</code>中）</em>的字符数组</li></ul><h3 id="11-2-tmpfile函数"><a href="#11-2-tmpfile函数" class="headerlink" title="11.2 tmpfile函数"></a>11.2 <code>tmpfile</code>函数</h3><h4 id="11-2-1-功能"><a href="#11-2-1-功能" class="headerlink" title="11.2.1 功能"></a>11.2.1 功能</h4><p>创建一个临时文件（类型为<code>wb+</code>）</p><h4 id="11-2-2-函数原型"><a href="#11-2-2-函数原型" class="headerlink" title="11.2.2 函数原型"></a>11.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回文件指针，出错返回NULL</span><br>FILE *<span class="hljs-title function_">tmpfile</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="11-2-3-注意"><a href="#11-2-3-注意" class="headerlink" title="11.2.3 注意"></a>11.2.3 注意</h4><p><code>tmpfile</code>创建的临时文件关闭或程序结束时会自动删除</p><h3 id="11-3-tempnam函数"><a href="#11-3-tempnam函数" class="headerlink" title="11.3 tempnam函数"></a>11.3 <code>tempnam</code>函数</h3><h4 id="11-3-1-功能"><a href="#11-3-1-功能" class="headerlink" title="11.3.1 功能"></a>11.3.1 功能</h4><p>生成并返回一个有效的临时文件名</p><h4 id="11-3-2-函数原型"><a href="#11-3-2-函数原型" class="headerlink" title="11.3.2 函数原型"></a>11.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 返回指向唯一路径名的指针（指向动态内存，须手动释放）</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">tempnam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *directory, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *prefix)</span>;<br></code></pre></td></tr></table></figure><h4 id="11-3-3-参数directory的确定顺序"><a href="#11-3-3-参数directory的确定顺序" class="headerlink" title="11.3.3 参数directory的确定顺序"></a>11.3.3 参数<code>directory</code>的确定顺序</h4><ol><li>环境变量<code>TMPDIR</code></li><li>非<code>NULL</code>的<code>directory</code></li><li>字符串<code>P_tmpdir</code><em>（定义在<code>&lt;stdio.h&gt;</code>中）</em></li><li>本地目录（通常是<code>/tmp</code>）</li></ol><h4 id="11-3-4-参数prefix"><a href="#11-3-4-参数prefix" class="headerlink" title="11.3.4 参数prefix"></a>11.3.4 参数<code>prefix</code></h4><p>如果<code>prefix</code>不为<code>NULL</code>，则其最多包含五个字符将作为文件名的开头</p><h3 id="11-4-mkstemp函数"><a href="#11-4-mkstemp函数" class="headerlink" title="11.4 mkstemp函数"></a>11.4 <code>mkstemp</code>函数</h3><h4 id="11-4-1-功能"><a href="#11-4-1-功能" class="headerlink" title="11.4.1 功能"></a>11.4.1 功能</h4><p>创建一个临时文件并打开</p><h4 id="11-4-2-函数原型"><a href="#11-4-2-函数原型" class="headerlink" title="11.4.2 函数原型"></a>11.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回文件描述符，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkstemp</span><span class="hljs-params">(<span class="hljs-type">char</span> *template)</span>;<br></code></pre></td></tr></table></figure><h4 id="11-4-3-注意"><a href="#11-4-3-注意" class="headerlink" title="11.4.3 注意"></a>11.4.3 注意</h4><p><code>mkstemp</code>创建的临时文件不会自动删除<em>（如果想要删除，需要自行<code>unlink</code>）</em></p>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 06 - System Data Files and Information</title>
    <link href="/2023/10/12/apue-ch06/"/>
    <url>/2023/10/12/apue-ch06/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-06-系统数据文件和信息"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-06-系统数据文件和信息" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 06 系统数据文件和信息"></a>Advanced Programming in the UNIX Environment—Chapter 06 系统数据文件和信息</h1><h2 id="1-口令文件"><a href="#1-口令文件" class="headerlink" title="1. 口令文件"></a>1. 口令文件</h2><h3 id="1-1-位置"><a href="#1-1-位置" class="headerlink" title="1.1 位置"></a>1.1 位置</h3><p><code>/etc/passwd</code></p><h3 id="1-2-结构体passwd"><a href="#1-2-结构体passwd" class="headerlink" title="1.2 结构体passwd"></a>1.2 结构体<code>passwd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *pw_name;   <span class="hljs-comment">/* username */</span><br>    <span class="hljs-type">char</span> *pw_passwd; <span class="hljs-comment">/* encrypted user password */</span><br>    <span class="hljs-type">uid_t</span> pw_uid;    <span class="hljs-comment">/* user ID */</span><br>    <span class="hljs-type">gid_t</span> pw_gid;    <span class="hljs-comment">/* group ID */</span><br>    <span class="hljs-type">char</span> *pw_gecos;  <span class="hljs-comment">/* user information */</span><br>    <span class="hljs-type">char</span> *pw_dir;    <span class="hljs-comment">/* home directory */</span><br>    <span class="hljs-type">char</span> *pw_shell;  <span class="hljs-comment">/* shell program */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-3-getpwuid和getpwnam函数"><a href="#1-3-getpwuid和getpwnam函数" class="headerlink" title="1.3 getpwuid和getpwnam函数"></a>1.3 <code>getpwuid</code>和<code>getpwnam</code>函数</h3><h4 id="1-3-1-功能"><a href="#1-3-1-功能" class="headerlink" title="1.3.1 功能"></a>1.3.1 功能</h4><p>获取用户的口令文件项</p><h4 id="1-3-2-函数原型"><a href="#1-3-2-函数原型" class="headerlink" title="1.3.2 函数原型"></a>1.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回对应指针，出错返回NULL</span><br><span class="hljs-keyword">struct</span> passwd *<span class="hljs-title function_">getpwuid</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid)</span>;<br><span class="hljs-keyword">struct</span> passwd *<span class="hljs-title function_">getpwnam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-应用"><a href="#1-3-3-应用" class="headerlink" title="1.3.3 应用"></a>1.3.3 应用</h4><p><code>ls</code>程序使用<code>getpwuid</code>函数</p><p><code>login</code>程序使用<code>getpwnam</code>函数</p><h3 id="1-4-getpwent、setpwent和endpwent函数"><a href="#1-4-getpwent、setpwent和endpwent函数" class="headerlink" title="1.4 getpwent、setpwent和endpwent函数"></a>1.4 <code>getpwent</code>、<code>setpwent</code>和<code>endpwent</code>函数</h3><h4 id="1-4-1-功能"><a href="#1-4-1-功能" class="headerlink" title="1.4.1 功能"></a>1.4.1 功能</h4><ul><li><code>getpwent</code>：自动打开密码文件，并按顺序读取各项</li><li><code>setpwent</code>：将文件指针重置回密码文件的起始处</li><li><code>endpwent</code>：关闭密码文件</li></ul><h4 id="1-4-2-函数原型"><a href="#1-4-2-函数原型" class="headerlink" title="1.4.2 函数原型"></a>1.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回指针，出错或到达文件结尾返回NULL</span><br><span class="hljs-keyword">struct</span> passwd *<span class="hljs-title function_">getpwent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setpwent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">endpwent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-4-3-实现getpwnam函数"><a href="#1-4-3-实现getpwnam函数" class="headerlink" title="1.4.3 实现getpwnam函数"></a>1.4.3 实现<code>getpwnam</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> passwd *<br><span class="hljs-title function_">getpwnam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> *<span class="hljs-title">ptr</span>;</span><br><br>    setpwent();<br>    <span class="hljs-keyword">while</span> ((ptr = getpwent()) != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// getpwent return value may point to a static area</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, ptr-&gt;pw_name) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* found a match */</span><br>    &#125;<br>    endpwent();<br>    <span class="hljs-keyword">return</span> ptr; <span class="hljs-comment">/* ptr is NULL if no match found */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-阴影口令"><a href="#2-阴影口令" class="headerlink" title="2. 阴影口令"></a>2. 阴影口令</h2><h3 id="2-1-位置"><a href="#2-1-位置" class="headerlink" title="2.1 位置"></a>2.1 位置</h3><p><code>/etc/shadow</code></p><h3 id="2-2-结构体spwd"><a href="#2-2-结构体spwd" class="headerlink" title="2.2 结构体spwd"></a>2.2 结构体<code>spwd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shadow.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spwd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *sp_namp;             <span class="hljs-comment">/* user login name */</span><br>    <span class="hljs-type">char</span> *sp_pwdp;             <span class="hljs-comment">/* encrypted password */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_lstchg;        <span class="hljs-comment">/* time since the last password change */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_min;           <span class="hljs-comment">/* minimum days before allowed change */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_max;           <span class="hljs-comment">/* maximum days before required change */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_warn;          <span class="hljs-comment">/* number of days for password expiration warning */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_inact;         <span class="hljs-comment">/* number of days before the account becomes inactive */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_expire;        <span class="hljs-comment">/* number of days until the account expires */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> sp_flag; <span class="hljs-comment">/* reserved */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3 函数"></a>2.3 函数</h3><p>功能类似1.3、1.4节函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shadow.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回指针，出错返回NULL</span><br><span class="hljs-keyword">struct</span> spwd *<span class="hljs-title function_">getspnam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-keyword">struct</span> spwd *<span class="hljs-title function_">getspent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setspent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">endspent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-组文件"><a href="#3-组文件" class="headerlink" title="3. 组文件"></a>3. 组文件</h2><h3 id="3-1-位置"><a href="#3-1-位置" class="headerlink" title="3.1 位置"></a>3.1 位置</h3><p><code>/etc/group</code></p><h3 id="3-2-结构体group"><a href="#3-2-结构体group" class="headerlink" title="3.2 结构体group"></a>3.2 结构体<code>group</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *gr_name;   <span class="hljs-comment">/* group name */</span><br>    <span class="hljs-type">char</span> *gr_passwd; <span class="hljs-comment">/* password */</span><br>    <span class="hljs-type">int</span> gr_gid;      <span class="hljs-comment">/* group ID */</span><br>    <span class="hljs-type">char</span> **gr_mem;   <span class="hljs-comment">/* list of group members */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-3-函数"><a href="#3-3-函数" class="headerlink" title="3.3 函数"></a>3.3 函数</h3><p>功能类似1.3、1.4节函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回指针，出错返回NULL</span><br><span class="hljs-keyword">struct</span> group *<span class="hljs-title function_">getgrgid</span><span class="hljs-params">(<span class="hljs-type">gid_t</span> gid)</span>;<br><span class="hljs-keyword">struct</span> group *<span class="hljs-title function_">getgrnam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-keyword">struct</span> group *<span class="hljs-title function_">getgrent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">setgrent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">endgrent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-附加组ID"><a href="#4-附加组ID" class="headerlink" title="4. 附加组ID"></a>4. 附加组ID</h2><h3 id="4-1-initgroups函数"><a href="#4-1-initgroups函数" class="headerlink" title="4.1 initgroups函数"></a>4.1 <code>initgroups</code>函数</h3><h4 id="4-1-1-功能"><a href="#4-1-1-功能" class="headerlink" title="4.1.1 功能"></a>4.1.1 功能</h4><p>初始化用户的附加组</p><h4 id="4-1-2-函数原型"><a href="#4-1-2-函数原型" class="headerlink" title="4.1.2 函数原型"></a>4.1.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">initgroups</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *username, <span class="hljs-type">gid_t</span> basegid)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-2-getgroups函数"><a href="#4-2-getgroups函数" class="headerlink" title="4.2 getgroups函数"></a>4.2 <code>getgroups</code>函数</h3><h4 id="4-2-1-功能"><a href="#4-2-1-功能" class="headerlink" title="4.2.1 功能"></a>4.2.1 功能</h4><p>获取进程的附加组ID</p><h4 id="4-2-2-函数原型"><a href="#4-2-2-函数原型" class="headerlink" title="4.2.2 函数原型"></a>4.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回附加组ID数，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getgroups</span><span class="hljs-params">(<span class="hljs-type">int</span> gidsetsize, <span class="hljs-type">gid_t</span> grouplist[])</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-setgroups函数"><a href="#4-3-setgroups函数" class="headerlink" title="4.3 setgroups函数"></a>4.3 <code>setgroups</code>函数</h3><h4 id="4-3-1-功能"><a href="#4-3-1-功能" class="headerlink" title="4.3.1 功能"></a>4.3.1 功能</h4><p>设置进程的附加组ID</p><h4 id="4-3-2-函数原型"><a href="#4-3-2-函数原型" class="headerlink" title="4.3.2 函数原型"></a>4.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setgroups</span><span class="hljs-params">(<span class="hljs-type">int</span> ngroups, <span class="hljs-type">const</span> <span class="hljs-type">gid_t</span> grouplist[])</span>;<br></code></pre></td></tr></table></figure><h2 id="5-系统标识"><a href="#5-系统标识" class="headerlink" title="5. 系统标识"></a>5. 系统标识</h2><h3 id="5-1-uname函数"><a href="#5-1-uname函数" class="headerlink" title="5.1 uname函数"></a>5.1 <code>uname</code>函数</h3><h4 id="5-1-1-功能"><a href="#5-1-1-功能" class="headerlink" title="5.1.1 功能"></a>5.1.1 功能</h4><p>返回当前主机和操作系统有关的信息</p><h4 id="5-1-2-结构体utsname"><a href="#5-1-2-结构体utsname" class="headerlink" title="5.1.2 结构体utsname"></a>5.1.2 结构体<code>utsname</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/utsname.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utsname</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> sysname[];  <span class="hljs-comment">/* name of the operating system */</span><br>    <span class="hljs-type">char</span> nodename[]; <span class="hljs-comment">/* name of this node */</span><br>    <span class="hljs-type">char</span> release[];  <span class="hljs-comment">/* current release of operating system */</span><br>    <span class="hljs-type">char</span> version[];  <span class="hljs-comment">/* current version of this release */</span><br>    <span class="hljs-type">char</span> machine[];  <span class="hljs-comment">/* name of hardware type */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-1-3-函数原型"><a href="#5-1-3-函数原型" class="headerlink" title="5.1.3 函数原型"></a>5.1.3 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/utsname.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回非负值，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">uname</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> utsname *name)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-2-gethostname函数"><a href="#5-2-gethostname函数" class="headerlink" title="5.2 gethostname函数"></a>5.2 <code>gethostname</code>函数</h3><h4 id="5-2-1-功能"><a href="#5-2-1-功能" class="headerlink" title="5.2.1 功能"></a>5.2.1 功能</h4><p>获取主机名（通常是TCP&#x2F;IP网络上的主机）</p><h4 id="5-2-2-函数原型"><a href="#5-2-2-函数原型" class="headerlink" title="5.2.2 函数原型"></a>5.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gethostname</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> namelen)</span>;<br></code></pre></td></tr></table></figure><h2 id="6-时间和日期例程"><a href="#6-时间和日期例程" class="headerlink" title="6. 时间和日期例程"></a>6. 时间和日期例程</h2><h3 id="6-1-与时间有关的类型"><a href="#6-1-与时间有关的类型" class="headerlink" title="6.1 与时间有关的类型"></a>6.1 与时间有关的类型</h3><h4 id="6-1-1-time-t"><a href="#6-1-1-time-t" class="headerlink" title="6.1.1 time_t"></a>6.1.1 <code>time_t</code></h4><p><code>time_t</code>表示自1970年1月1日以来的秒数</p><h4 id="6-1-2-结构体timeval"><a href="#6-1-2-结构体timeval" class="headerlink" title="6.1.2 结构体timeval"></a>6.1.2 结构体<code>timeval</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> tv_sec;  <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-type">long</span> tv_usec; <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6-1-3-结构体timezone"><a href="#6-1-3-结构体timezone" class="headerlink" title="6.1.3 结构体timezone"></a>6.1.3 结构体<code>timezone</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timezone</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> tz_minuteswest; <span class="hljs-comment">/* of Greenwich */</span><br>    <span class="hljs-type">int</span> tz_dsttime;     <span class="hljs-comment">/* type of dst correction to apply */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6-1-4-结构体tm"><a href="#6-1-4-结构体tm" class="headerlink" title="6.1.4 结构体tm"></a>6.1.4 结构体<code>tm</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> tm_sec;   <span class="hljs-comment">/* seconds after the minute: [0-60] */</span><br>    <span class="hljs-type">int</span> tm_min;   <span class="hljs-comment">/* minutes after the hour: [0-59] */</span><br>    <span class="hljs-type">int</span> tm_hour;  <span class="hljs-comment">/* hours after the midnight: [0-23] */</span><br>    <span class="hljs-type">int</span> tm_mday;  <span class="hljs-comment">/* day of the month: [1-31] */</span><br>    <span class="hljs-type">int</span> tm_mon;   <span class="hljs-comment">/* months since January: [0-11] */</span><br>    <span class="hljs-type">int</span> tm_year;  <span class="hljs-comment">/* years since 1900 */</span><br>    <span class="hljs-type">int</span> tm_wday;  <span class="hljs-comment">/* days since Sunday: [0-6] */</span><br>    <span class="hljs-type">int</span> tm_yday;  <span class="hljs-comment">/* days since January 1: [0-365] */</span><br>    <span class="hljs-type">int</span> tm_isdst; <span class="hljs-comment">/* daylight saving time flag */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-2-时间获取"><a href="#6-2-时间获取" class="headerlink" title="6.2 时间获取"></a>6.2 时间获取</h3><h4 id="6-2-1-time函数"><a href="#6-2-1-time函数" class="headerlink" title="6.2.1 time函数"></a>6.2.1 <code>time</code>函数</h4><p>获取自1970年1月1日以来的秒数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回时间值，出错返回-1</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *calptr)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-gettimeofday"><a href="#6-2-2-gettimeofday" class="headerlink" title="6.2.2 gettimeofday"></a>6.2.2 <code>gettimeofday</code></h4><p>获取当前精确时间（微秒级）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-comment">// 总是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gettimeofday</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *tv, <span class="hljs-keyword">struct</span> timezone *tz)</span>;<br></code></pre></td></tr></table></figure><h3 id="6-3-时间转换"><a href="#6-3-时间转换" class="headerlink" title="6.3 时间转换"></a>6.3 时间转换</h3><h4 id="6-3-1-gmtime和localtime函数"><a href="#6-3-1-gmtime和localtime函数" class="headerlink" title="6.3.1 gmtime和localtime函数"></a>6.3.1 <code>gmtime</code>和<code>localtime</code>函数</h4><ul><li><code>gmtime</code>：将日历时间转换为国际标准时间</li><li><code>localtime</code>：将日历时间转换为本地时间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 返回指向结构体tm的指针</span><br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">gmtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span> *calptr)</span>;<br><span class="hljs-keyword">struct</span> tm *<span class="hljs-title function_">localtime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span> *calptr)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-2-mktime函数"><a href="#6-3-2-mktime函数" class="headerlink" title="6.3.2 mktime函数"></a>6.3.2 <code>mktime</code>函数</h4><p><code>struct tm</code>转换为<code>time_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回日历时间，出错返回-1</span><br><span class="hljs-type">time_t</span> <span class="hljs-title function_">mktime</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tm *tmptr)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-3-asctime和ctime函数"><a href="#6-3-3-asctime和ctime函数" class="headerlink" title="6.3.3 asctime和ctime函数"></a>6.3.3 <code>asctime</code>和<code>ctime</code>函数</h4><p>将日期表示转换为26字节的字符串形式，例如：<code>Tue Feb 10 18:27:38 2004\n\0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 返回以null结尾的字符串的指针</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">asctime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> tm *timeptr)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">ctime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">time_t</span> *time)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-4-strftime函数"><a href="#6-3-4-strftime函数" class="headerlink" title="6.3.4 strftime函数"></a>6.3.4 <code>strftime</code>函数</h4><p>根据指定的格式将<code>struct tm</code>类型的时间信息转换为一个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 若有空间则返回存入数组的字符数，否则返回0</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strftime</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">size_t</span> maxsize, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> tm *timeptr)</span>;<br></code></pre></td></tr></table></figure><h3 id="6-4-时间函数之间的关系"><a href="#6-4-时间函数之间的关系" class="headerlink" title="6.4 时间函数之间的关系"></a>6.4 时间函数之间的关系</h3><p><img src="/2023/10/12/apue-ch06/relationship.png" alt="各个时间函数之间的关系"></p>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Thread (Part 1)</title>
    <link href="/2023/10/09/cpp-thread-1/"/>
    <url>/2023/10/09/cpp-thread-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-线程（一）"><a href="#C-线程（一）" class="headerlink" title="C++线程（一）"></a>C++线程（一）</h1><h2 id="1-std-thread-id类"><a href="#1-std-thread-id类" class="headerlink" title="1. std::thread::id类"></a>1. <code>std::thread::id</code>类</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><ul><li><code>std::thread</code>和<code>std::jthread</code>对象的唯一标识符</li><li>作为有序和无序关联容器的键</li></ul><h3 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h3><p>默认构造函数构造<strong>不表示任何线程的 ID</strong>，原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">id</span>() <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-非成员函数"><a href="#1-3-非成员函数" class="headerlink" title="1.3 非成员函数"></a>1.3 非成员函数</h3><ul><li>比较运算符：<code>operator==</code>  <code>operator&lt;</code>等</li><li>输出运算符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CharT</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traits</span>&gt;<br>std::basic_ostream&lt;CharT, Traits&gt; &amp;<br><span class="hljs-keyword">operator</span>&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt; &amp;ost, std::thread::id id);<br></code></pre></td></tr></table></figure><h3 id="1-4-注意"><a href="#1-4-注意" class="headerlink" title="1.4 注意"></a>1.4 注意</h3><ul><li><code>std::thread::id</code>的实例可以不表示任何线程</li><li>线程结束，<code>std::thread::id</code>的值可为另一线程复用</li></ul><h2 id="2-std-thread类"><a href="#2-std-thread类" class="headerlink" title="2. std::thread类"></a>2. <code>std::thread</code>类</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><code>std::thread</code>类表示单个执行线程，定义在头文件<code>&lt;thread&gt;</code>中<em>（C++11起）</em></p><h3 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h3><h4 id="2-2-1-构造函数"><a href="#2-2-1-构造函数" class="headerlink" title="2.2.1 构造函数"></a>2.2.1 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">thread</span>() <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-built_in">thread</span>(<span class="hljs-type">const</span> thread &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// std::thread对象不能拷贝</span><br><span class="hljs-built_in">thread</span>(thread &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Function</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread</span><span class="hljs-params">(Function &amp;&amp;f, Args &amp;...args)</span></span>;<br></code></pre></td></tr></table></figure><p>构造函数的参数是任何可调用对象，可以为函数名（函数指针）、仿函数（重载<code>operator()</code>的类）、<em>lambda</em>表达式</p><ul><li>函数名（函数指针）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; number &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func, <span class="hljs-number">100</span>)</span></span>;   <span class="hljs-comment">// OK</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;func, <span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><ul><li>仿函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">background_task</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(background_task&#123;&#125;)</span></span>;  <span class="hljs-comment">// OK</span><br>std::thread t1&#123;<span class="hljs-built_in">background_task</span>()&#125;; <span class="hljs-comment">// OK</span><br>std::thread t2&#123;background_task&#123;&#125;&#125;; <span class="hljs-comment">// OK</span><br><span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(background_task())</span></span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><ul><li><em>lambda</em>表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() -&gt; <span class="hljs-type">void</span> &#123; std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; &#125;)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-析构函数"><a href="#2-2-2-析构函数" class="headerlink" title="2.2.2 析构函数"></a>2.2.2 析构函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">thread</span>();<br></code></pre></td></tr></table></figure><ul><li>若<code>*this</code>拥有关联线程（<code>joinable() == true </code>），则调用<code>std::terminate()</code></li><li>在下列操作后<code>std::thread</code>对象无关联的线程（可安全销毁）<ul><li>被默认构造</li><li>被移动</li><li>已调用<code>join()</code></li><li>已调用<code>detach()</code></li></ul></li></ul><h4 id="2-2-3-赋值运算符"><a href="#2-2-3-赋值运算符" class="headerlink" title="2.2.3 赋值运算符"></a>2.2.3 赋值运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">thread &amp;<span class="hljs-keyword">operator</span>=(thread &amp;&amp;other) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// std::thread类拷贝赋值运算符被定义为删除的函数</span><br></code></pre></td></tr></table></figure><ul><li><p>若<code>*this</code>仍拥有关联的运行中进程（即<code>joinable() == true</code>），则调用<code>std::terminate()</code> ；否则，赋值<code>other</code>的状态给<code>*this</code>并设置<code>other</code>为默认构造的状态</p></li><li><p>此调用后，<code>this-&gt;get_id() </code>等于<code>other.get_id()</code>在<code>operator=</code>调用前的值，而<code>other</code>不再表示执行的线程</p></li></ul><h4 id="2-2-4-观察器"><a href="#2-2-4-观察器" class="headerlink" title="2.2.4 观察器"></a>2.2.4 观察器</h4><ul><li><code>joinable</code>：检查<code>std::thread</code>对象是否标识<strong>活跃</strong>的执行线程。具体而言，若<code>get_id() != std::thread::id()</code>则返回<code>true</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">joinable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; std::boolalpha;<br><br>    std::thread t;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;before starting, joinable: &quot;</span> &lt;&lt; t.<span class="hljs-built_in">joinable</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    t = std::thread&#123;foo&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t.<span class="hljs-built_in">joinable</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;after joining, joinable: &quot;</span> &lt;&lt; t.<span class="hljs-built_in">joinable</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    t = std::thread&#123;foo&#125;;<br>    t.<span class="hljs-built_in">detach</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;after detaching, joinable: &quot;</span> &lt;&lt; t.<span class="hljs-built_in">joinable</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">before starting, joinable: false<br>after starting, joinable: true<br>after joining, joinable: false<br>after detaching, joinable: false<br></code></pre></td></tr></table></figure><ul><li><code>get_id</code>：返回线程ID。若无关联的线程，则返回默认构造的<code>std::thread::id</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::<span class="hljs-function">thread::id <span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo)</span></span>;<br>    std::thread::id t1_id = t1.<span class="hljs-built_in">get_id</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(foo)</span></span>;<br>    std::thread::id t2_id = t2.<span class="hljs-built_in">get_id</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;t1&#x27;s id: &quot;</span> &lt;&lt; t1_id &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;t2&#x27;s id: &quot;</span> &lt;&lt; t2_id &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可能的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">t1&#x27;s id: 2<br>t2&#x27;s id: 3<br></code></pre></td></tr></table></figure><ul><li><code>native_handle</code>：返回实现定义的底层线程柄</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ++">native_handle_type native_handle();<br></code></pre></td></tr></table></figure><ul><li><code>hardware_concurrency</code>：返回实现支持的并发线程数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">hardware_concurrency</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-5-操作"><a href="#2-2-5-操作" class="headerlink" title="2.2.5 操作"></a>2.2.5 操作</h4><ul><li><code>join</code>：阻塞当前线程直至 <code>*this</code>所标识的线程结束其执行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>detach</code>：使<code>thread</code>对象的执行线程独立运行，并在结束时自动释放资源。调用后，<code>*this</code>不再关联任何线程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">detach</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">independentThread</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Starting concurrent thread.\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting concurrent thread.\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadCaller</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Starting thread caller.\n&quot;</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(independentThread)</span></span>;<br>    t.<span class="hljs-built_in">detach</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting thread caller.\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">threadCaller</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可能的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">Starting thread caller.<br>Starting concurrent thread.<br>Exiting thread caller.<br>Exiting concurrent thread.<br></code></pre></td></tr></table></figure><ul><li><code>swap</code>：交换两个<code>thread</code>对象的底层柄</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(std::thread &amp;other)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-非成员函数"><a href="#2-3-非成员函数" class="headerlink" title="2.3 非成员函数"></a>2.3 非成员函数</h3><ul><li><code>std::swap</code>：交换<code>lhs</code>与<code>rhs</code>的状态，等效调用<code>lhs.swap(rhs)</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(std::thread &amp;lhs, std::thread &amp;rhs)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Standard Library</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 04 - Files and Directories</title>
    <link href="/2023/10/08/apue-ch04/"/>
    <url>/2023/10/08/apue-ch04/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-04-文件和目录"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-04-文件和目录" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 04  文件和目录"></a>Advanced Programming in the UNIX Environment—Chapter 04  文件和目录</h1><h2 id="1-stat、fstat和lstat函数"><a href="#1-stat、fstat和lstat函数" class="headerlink" title="1. stat、fstat和lstat函数"></a>1. <code>stat</code>、<code>fstat</code>和<code>lstat</code>函数</h2><h3 id="1-1-功能"><a href="#1-1-功能" class="headerlink" title="1.1 功能"></a>1.1 功能</h3><p>获取文件有关信息，其中<code>lstat</code>获取<strong>符号链接本身</strong>的信息，并不是链接所指向的文件的信息</p><h3 id="1-2-函数原型"><a href="#1-2-函数原型" class="headerlink" title="1.2 函数原型"></a>1.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">struct</span> stat *<span class="hljs-keyword">restrict</span> buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">struct</span> stat *<span class="hljs-keyword">restrict</span> buf)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-结构体stat"><a href="#1-3-结构体stat" class="headerlink" title="1.3 结构体stat"></a>1.3 结构体<code>stat</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">mode_t</span> st_mode;       <span class="hljs-comment">/* permissions */</span><br>    <span class="hljs-type">ino_t</span> st_ino;         <span class="hljs-comment">/* i-node number */</span><br>    <span class="hljs-type">dev_t</span> st_dev;         <span class="hljs-comment">/* device number */</span><br>    <span class="hljs-type">dev_t</span> st_rdev;        <span class="hljs-comment">/* device number for special files */</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;     <span class="hljs-comment">/* number of links */</span><br>    <span class="hljs-type">uid_t</span> st_uid;         <span class="hljs-comment">/* user ID of owner */</span><br>    <span class="hljs-type">gid_t</span> st_gid;         <span class="hljs-comment">/* group ID of owner */</span><br>    <span class="hljs-type">off_t</span> st_size;        <span class="hljs-comment">/* size in bytes, for regular files */</span><br>    <span class="hljs-type">time_t</span> st_atime;      <span class="hljs-comment">/* access */</span><br>    <span class="hljs-type">time_t</span> st_mtime;      <span class="hljs-comment">/* modify */</span><br>    <span class="hljs-type">time_t</span> st_ctime;      <span class="hljs-comment">/* status change */</span><br>    <span class="hljs-type">blksize_t</span> st_blksize; <span class="hljs-comment">/* best I/O block size */</span><br>    <span class="hljs-type">blkcnt_t</span> st_blocks;   <span class="hljs-comment">/* number of disk blocks allocated */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><p><code>ls -l</code>命令</p><h2 id="2-文件类型"><a href="#2-文件类型" class="headerlink" title="2. 文件类型"></a>2. 文件类型</h2><h3 id="2-1-文件分类"><a href="#2-1-文件分类" class="headerlink" title="2.1 文件分类"></a>2.1 文件分类</h3><ul><li>普通文件（regular file）</li><li>目录文件（directory file）</li><li>块特殊文件（block special file）：提供对设备<strong>带缓冲</strong>的访问，每次访问以<strong>固定长度</strong>为单位进行</li><li>字符特殊文件（character special file）：提供对设备<strong>不带缓冲</strong>的访问，每次<strong>访问长度可变</strong></li><li>FIFO：用于进程间通信，也称为<strong>管道</strong></li><li>套接字（socket）：用于进程间网络通信，也可用在一台机器上进程间非网络通信</li><li>符号链接（symbolic link）</li></ul><h3 id="2-2-文件类型宏"><a href="#2-2-文件类型宏" class="headerlink" title="2.2 文件类型宏"></a>2.2 文件类型宏</h3><p>宏参数：<code>struct stat</code>中的<code>st_mode</code>成员</p><table><thead><tr><th align="center">宏</th><th align="center">文件类型</th></tr></thead><tbody><tr><td align="center"><code>S_ISREG()</code></td><td align="center">普通文件</td></tr><tr><td align="center"><code>S_ISDIR()</code></td><td align="center">目录文件</td></tr><tr><td align="center"><code>S_ISCHR()</code></td><td align="center">字符特殊文件</td></tr><tr><td align="center"><code>S_ISBLK()</code></td><td align="center">块特殊文件</td></tr><tr><td align="center"><code>S_ISFIFO()</code></td><td align="center">管道或FIFO</td></tr><tr><td align="center"><code>S_ISLNK()</code></td><td align="center">符号链接</td></tr><tr><td align="center"><code>S_ISSOCK()</code></td><td align="center">套接字</td></tr></tbody></table><h3 id="2-3-IPC类型宏"><a href="#2-3-IPC类型宏" class="headerlink" title="2.3 IPC类型宏"></a>2.3 IPC类型宏</h3><p>宏参数：<code>struct stat *</code></p><table><thead><tr><th align="center">宏</th><th align="center">对象类型</th></tr></thead><tbody><tr><td align="center"><code>S_TYPEISMQ()</code></td><td align="center">消息队列</td></tr><tr><td align="center"><code>S_TYPEISSEM()</code></td><td align="center">信号量</td></tr><tr><td align="center"><code>S_TYPEISSHM()</code></td><td align="center">共享存储对象</td></tr></tbody></table><h2 id="3-与进程有关的ID"><a href="#3-与进程有关的ID" class="headerlink" title="3. 与进程有关的ID"></a>3. 与进程有关的ID</h2><h3 id="3-1-实际用户ID-实际组ID"><a href="#3-1-实际用户ID-实际组ID" class="headerlink" title="3.1 实际用户ID 实际组ID"></a>3.1 实际用户ID 实际组ID</h3><ul><li>当前登录用户的ID及其所属组的ID</li><li>登录时取自口令文件中的登录项</li></ul><h3 id="3-2-有效用户ID-有效组ID-附加组ID"><a href="#3-2-有效用户ID-有效组ID-附加组ID" class="headerlink" title="3.2 有效用户ID 有效组ID 附加组ID"></a>3.2 有效用户ID 有效组ID 附加组ID</h3><ul><li>用于文件访问权限检查</li></ul><h3 id="3-3-保存的设置用户ID-保存的设置组ID"><a href="#3-3-保存的设置用户ID-保存的设置组ID" class="headerlink" title="3.3 保存的设置用户ID 保存的设置组ID"></a>3.3 保存的设置用户ID 保存的设置组ID</h3><ul><li>当进程执行某文件时，进程的有效用户ID设置为文件所有者的用户ID</li><li>当进程执行某文件时，进程的有效组ID设置为文件组所有者ID</li></ul><h2 id="4-文件访问权限"><a href="#4-文件访问权限" class="headerlink" title="4. 文件访问权限"></a>4. 文件访问权限</h2><h3 id="4-1-打开某文件时"><a href="#4-1-打开某文件时" class="headerlink" title="4.1 打开某文件时"></a>4.1 打开某文件时</h3><ul><li>该文件绝对路径中包含的所有目录都应有<strong>执行权限</strong>。如打开文件<code>/usr/include/stdio.h</code>，需要对目录<code>/</code>、<code>/usr</code>、<code>/usr/include</code>具有执行权限</li><li>需要对文件本身的适当权限</li></ul><h3 id="4-2-目录文件的权限"><a href="#4-2-目录文件的权限" class="headerlink" title="4.2 目录文件的权限"></a>4.2 目录文件的权限</h3><ul><li><p>读权限：允许获取目录中所有文件名</p></li><li><p>写权限：允许在目录中添加或删除文件</p></li><li><p>执行权限：允许在目录中查找</p></li></ul><h2 id="5-新文件和目录的所有权"><a href="#5-新文件和目录的所有权" class="headerlink" title="5. 新文件和目录的所有权"></a>5. 新文件和目录的所有权</h2><ul><li>用户ID：进程的有效用户ID</li><li>组ID<ul><li>有效组ID</li><li>所在目录的组ID</li></ul></li></ul><h2 id="6-access函数"><a href="#6-access函数" class="headerlink" title="6. access函数"></a>6. <code>access</code>函数</h2><h3 id="6-1-功能"><a href="#6-1-功能" class="headerlink" title="6.1 功能"></a>6.1 功能</h3><p>以<strong>实际用户ID</strong>和<strong>实际组ID</strong>测试访问能力<em>（因为内核以进程的有效用户ID和有效组ID为基础执行访问权限测试）</em></p><h3 id="6-2-函数原型"><a href="#6-2-函数原型" class="headerlink" title="6.2 函数原型"></a>6.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="6-3-参数mode"><a href="#6-3-参数mode" class="headerlink" title="6.3 参数mode"></a>6.3 参数<code>mode</code></h3><table><thead><tr><th align="center"><code>mode</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>R_OK</code></td><td align="center">测试读权限</td></tr><tr><td align="center"><code>W_OK</code></td><td align="center">测试写权限</td></tr><tr><td align="center"><code>X_OK</code></td><td align="center">测试执行权限</td></tr><tr><td align="center"><code>F_OK</code></td><td align="center">测试文件是否存在</td></tr></tbody></table><h2 id="7-umask函数"><a href="#7-umask函数" class="headerlink" title="7. umask函数"></a>7. <code>umask</code>函数</h2><h3 id="7-1-功能"><a href="#7-1-功能" class="headerlink" title="7.1 功能"></a>7.1 功能</h3><p>创建文件屏蔽字（用于屏蔽或关闭某些文件权限，以确保文件只能以受限的方式被访问）</p><h3 id="7-2-函数原型"><a href="#7-2-函数原型" class="headerlink" title="7.2 函数原型"></a>7.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-comment">// 返回值：以前的文件模式创建屏蔽字</span><br><span class="hljs-type">mode_t</span> <span class="hljs-title function_">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span>;<br></code></pre></td></tr></table></figure><h3 id="7-3-示例"><a href="#7-3-示例" class="headerlink" title="7.3 示例"></a>7.3 示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">mode_t</span> mode = <span class="hljs-number">0666</span>; <span class="hljs-comment">// S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span><br>    <span class="hljs-type">mode_t</span> mask = <span class="hljs-number">0002</span>; <span class="hljs-comment">// S_IWOTH</span><br><br>    umask(mask);<br>    creat(<span class="hljs-string">&quot;test.txt&quot;</span>, mode);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs BASH">$ gcc test.c<br>$ ./a.out<br>$ <span class="hljs-built_in">ls</span> -l test.txt<br>-rw-rw-r--. 1 root root 0 Oct  1 04:09 test.txt<br></code></pre></td></tr></table></figure><h2 id="8-chmod和fchmod函数"><a href="#8-chmod和fchmod函数" class="headerlink" title="8. chmod和fchmod函数"></a>8. <code>chmod</code>和<code>fchmod</code>函数</h2><h3 id="8-1-功能"><a href="#8-1-功能" class="headerlink" title="8.1 功能"></a>8.1 功能</h3><p>更改现有文件的访问权限，必须满足如下条件之一：</p><ul><li>进程的有效用户ID等于文件所有者ID</li><li>进程具有超级用户权限</li></ul><h3 id="8-2-函数原型"><a href="#8-2-函数原型" class="headerlink" title="8.2 函数原型"></a>8.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-3-mode参数"><a href="#8-3-mode参数" class="headerlink" title="8.3 mode参数"></a>8.3 <code>mode</code>参数</h3><table><thead><tr><th align="center"><code>mode</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>S_ISUID</code><br><code>S_ISGID</code><br><code>S_ISVTX</code></td><td align="center">执行时设置用户ID<br>执行时设置组ID<br>保存正文（粘滞位）</td></tr><tr><td align="center"><code>S_IRWXU</code><br><code>S_IRUSR</code><br><code>S_IWUSR</code><br><code>S_IXUSR</code></td><td align="center">用户（所有者）读、写和执行<br>用户（所有者）读<br>用户（所有者）写<br>用户（所有者）执行</td></tr><tr><td align="center"><code>S_IRWXG</code><br><code>S_IRGRP</code><br><code>S_IWGRP</code><br><code>S_IXGRP</code></td><td align="center">组读、写和执行<br>组读<br>组写<br>组执行</td></tr><tr><td align="center"><code>S_IRWXO</code><br><code>S_IROTH</code><br><code>S_IWOTH</code><br><code>S_IXOTH</code></td><td align="center">其他读、写和执行<br>其他读<br>其他写<br>其他执行</td></tr></tbody></table><h2 id="9-粘滞位"><a href="#9-粘滞位" class="headerlink" title="9. 粘滞位"></a>9. 粘滞位</h2><p>目录上设置粘滞位，对目录具有写权限的用户满足以下任一条件才能删除或更名该目录下的文件：</p><ul><li>拥有此文件</li><li>拥有此目录</li><li>是超级用户</li></ul><h2 id="10-chown、fchown和lchown函数"><a href="#10-chown、fchown和lchown函数" class="headerlink" title="10. chown、fchown和lchown函数"></a>10. <code>chown</code>、<code>fchown</code>和<code>lchown</code>函数</h2><h3 id="10-1-功能"><a href="#10-1-功能" class="headerlink" title="10.1 功能"></a>10.1 功能</h3><p>更改文件的用户ID和组ID，其中<code>lchown</code>更改<strong>符号链接本身</strong>的所有者，而不是符号链接所指向的文件</p><h3 id="10-2-函数原型"><a href="#10-2-函数原型" class="headerlink" title="10.2 函数原型"></a>10.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<br></code></pre></td></tr></table></figure><h3 id="10-3-注意"><a href="#10-3-注意" class="headerlink" title="10.3 注意"></a>10.3 注意</h3><ul><li><p><code>owner</code>为-1，不修改用户ID</p></li><li><p><code>group</code>为-1，不修改组ID</p></li></ul><h2 id="11-文件长度"><a href="#11-文件长度" class="headerlink" title="11. 文件长度"></a>11. 文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件长度，此字段只对普通文件、目录文件和符号链接有意义</p><h2 id="12-truncate和ftruncate函数"><a href="#12-truncate和ftruncate函数" class="headerlink" title="12. truncate和ftruncate函数"></a>12. <code>truncate</code>和<code>ftruncate</code>函数</h2><h3 id="12-1-功能"><a href="#12-1-功能" class="headerlink" title="12.1 功能"></a>12.1 功能</h3><p>删减文件尾部数据以缩小文件大小</p><h3 id="12-2-函数原型"><a href="#12-2-函数原型" class="headerlink" title="12.2 函数原型"></a>12.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">off_t</span> length)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> length)</span>;<br></code></pre></td></tr></table></figure><h3 id="12-3-特例"><a href="#12-3-特例" class="headerlink" title="12.3 特例"></a>12.3 特例</h3><p>文件清空（打开文件使用<code>O_TRUNC</code>标志）</p><h2 id="13-硬链接"><a href="#13-硬链接" class="headerlink" title="13. 硬链接"></a>13. 硬链接</h2><h3 id="13-1-link函数"><a href="#13-1-link函数" class="headerlink" title="13.1 link函数"></a>13.1 <code>link</code>函数</h3><h4 id="13-1-1-功能"><a href="#13-1-1-功能" class="headerlink" title="13.1.1 功能"></a>13.1.1 功能</h4><p>创建硬链接</p><h4 id="13-1-2-函数原型"><a href="#13-1-2-函数原型" class="headerlink" title="13.1.2 函数原型"></a>13.1.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *existingpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br></code></pre></td></tr></table></figure><h4 id="13-1-3-注意"><a href="#13-1-3-注意" class="headerlink" title="13.1.3 注意"></a>13.1.3 注意</h4><ul><li>若<code>newpath</code>已存在，函数返回出错</li><li>函数只创建<code>newpath</code>中的最后一个分量，路径中的其他部分应当已经存在</li><li>避免创建指向目录的硬链接</li><li>不支持跨文件系统创建硬链接</li></ul><h4 id="13-1-4-示例"><a href="#13-1-4-示例" class="headerlink" title="13.1.4 示例"></a>13.1.4 示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-number">0666</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;creat error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (link(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test.txt.link&quot;</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;link error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-2-unlink函数"><a href="#13-2-unlink函数" class="headerlink" title="13.2 unlink函数"></a>13.2 <code>unlink</code>函数</h3><h4 id="13-2-1-功能"><a href="#13-2-1-功能" class="headerlink" title="13.2.1 功能"></a>13.2.1 功能</h4><p>删除链接</p><h4 id="13-2-2-函数原型"><a href="#13-2-2-函数原型" class="headerlink" title="13.2.2 函数原型"></a>13.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure><h4 id="13-2-3-注意"><a href="#13-2-3-注意" class="headerlink" title="13.2.3 注意"></a>13.2.3 注意</h4><p>若<code>pathname</code>是符号链接，则删除符号链接本身，而不是符号链接指向的文件</p><h4 id="13-2-4-应用：创建临时文件"><a href="#13-2-4-应用：创建临时文件" class="headerlink" title="13.2.4 应用：创建临时文件"></a>13.2.4 应用：创建临时文件</h4><p><code>unlink</code>函数创建临时文件的原理：通过<code>open</code>创建文件，<code>unlink</code>删除目录项但保留inode节点，最后文件描述符关闭时释放资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br><br>    <span class="hljs-comment">/* 创建一个新文件 */</span><br>    fd = open(<span class="hljs-string">&quot;tempfile&quot;</span>, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 错误处理 */</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除文件 */</span><br>    <span class="hljs-keyword">if</span> (unlink(<span class="hljs-string">&quot;tempfile&quot;</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 错误处理 */</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 此时可以通过文件描述符fd来读写文件的内容 */</span><br><br>    <span class="hljs-comment">/* 程序结束，打开的文件描述符会被自动关闭，相关资源也会被自动释放 */</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-符号链接"><a href="#14-符号链接" class="headerlink" title="14. 符号链接"></a>14. 符号链接</h2><h3 id="14-1symlink函数"><a href="#14-1symlink函数" class="headerlink" title="14.1symlink函数"></a>14.1<code>symlink</code>函数</h3><h4 id="14-1-1-功能"><a href="#14-1-1-功能" class="headerlink" title="14.1.1 功能"></a>14.1.1 功能</h4><p>创建符号链接</p><h4 id="14-1-2-函数原型"><a href="#14-1-2-函数原型" class="headerlink" title="14.1.2 函数原型"></a>14.1.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *actualpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *sympath)</span>;<br></code></pre></td></tr></table></figure><h4 id="14-1-3-注意"><a href="#14-1-3-注意" class="headerlink" title="14.1.3 注意"></a>14.1.3 注意</h4><p><code>actualpath</code>并不要求一定存在<em>（<code>ln -s</code>创建符号链接亦是如此）</em></p><h3 id="14-2-readlink函数"><a href="#14-2-readlink函数" class="headerlink" title="14.2 readlink函数"></a>14.2 <code>readlink</code>函数</h3><h4 id="14-2-1-功能"><a href="#14-2-1-功能" class="headerlink" title="14.2.1 功能"></a>14.2.1 功能</h4><p>读取符号链接本身内容</p><h4 id="14-2-2-函数原型"><a href="#14-2-2-函数原型" class="headerlink" title="14.2.2 函数原型"></a>14.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回读到的字节数，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-type">size_t</span> bufsize)</span>;<br></code></pre></td></tr></table></figure><h4 id="14-2-3-注意"><a href="#14-2-3-注意" class="headerlink" title="14.2.3 注意"></a>14.2.3 注意</h4><ul><li><code>readlink</code>函数组合了<code>open</code>、<code>read</code>和<code>close</code>的所有操作</li><li><strong><code>buf</code>中返回的符号链接内容不以null字符终止</strong></li></ul><h2 id="15-文件-目录操作"><a href="#15-文件-目录操作" class="headerlink" title="15. 文件&#x2F;目录操作"></a>15. 文件&#x2F;目录操作</h2><h3 id="15-1-mkdir函数"><a href="#15-1-mkdir函数" class="headerlink" title="15.1 mkdir函数"></a>15.1 <code>mkdir</code>函数</h3><h4 id="15-1-1-功能"><a href="#15-1-1-功能" class="headerlink" title="15.1.1 功能"></a>15.1.1 功能</h4><p>创建目录</p><h4 id="15-1-2-函数原型"><a href="#15-1-2-函数原型" class="headerlink" title="15.1.2 函数原型"></a>15.1.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="15-2-rename函数"><a href="#15-2-rename函数" class="headerlink" title="15.2 rename函数"></a>15.2 <code>rename</code>函数</h3><h4 id="15-2-1-功能"><a href="#15-2-1-功能" class="headerlink" title="15.2.1 功能"></a>15.2.1 功能</h4><p>对文件或目录进行更名</p><h4 id="15-2-2-函数原型"><a href="#15-2-2-函数原型" class="headerlink" title="15.2.2 函数原型"></a>15.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newname)</span>;<br></code></pre></td></tr></table></figure><h4 id="15-2-3-注意"><a href="#15-2-3-注意" class="headerlink" title="15.2.3 注意"></a>15.2.3 注意</h4><ul><li><code>oldname</code>和<code>newname</code>引用同一文件，函数不做任何更改而成功返回</li><li><code>oldname</code>和<code>newname</code>引用符号链接，则处理的是符号链接本身，而不是所引用的文件</li><li><code>oldname</code>引用的是文件，则为文件更名<ul><li><code>newname</code><strong>不能引用一个目录</strong></li><li>若<code>newname</code>已存在，则先将<code>newname</code>删除，后将<code>oldname</code>更名为<code>newname</code></li><li>对包含<code>oldname</code>的目录和<code>newname</code>的目录，进程必须具有写权限</li></ul></li><li><code>oldname</code>引用的是目录，则为目录更名<ul><li><code>newname</code><strong>必须引用一个目录（且应是空目录）</strong></li><li>若<code>newname</code>已存在，则先将<code>newname</code>删除，后将<code>oldname</code>更名为<code>newname</code></li><li><code>newname</code>不能以<code>oldname</code>作为路径前缀。例如，不能将<code>/usr/foo</code>更名为<code>/usr/foo/testdir</code></li></ul></li></ul><h3 id="15-3-rmdir函数"><a href="#15-3-rmdir函数" class="headerlink" title="15.3 rmdir函数"></a>15.3 <code>rmdir</code>函数</h3><h4 id="15-3-1-功能"><a href="#15-3-1-功能" class="headerlink" title="15.3.1 功能"></a>15.3.1 功能</h4><p>删除空目录</p><h4 id="15-3-2-函数原型"><a href="#15-3-2-函数原型" class="headerlink" title="15.3.2 函数原型"></a>15.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> pathname)</span>;<br></code></pre></td></tr></table></figure><h3 id="15-4-remove函数"><a href="#15-4-remove函数" class="headerlink" title="15.4 remove函数"></a>15.4 <code>remove</code>函数</h3><h4 id="15-4-1-功能"><a href="#15-4-1-功能" class="headerlink" title="15.4.1 功能"></a>15.4.1 功能</h4><ul><li>对于文件：<code>remove</code>与<code>unlink</code>功能相同</li><li>对于目录：<code>remove</code>与<code>rmdir</code>功能相同</li></ul><h4 id="15-4-2-函数原型"><a href="#15-4-2-函数原型" class="headerlink" title="15.4.2 函数原型"></a>15.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure><h2 id="16-读目录"><a href="#16-读目录" class="headerlink" title="16. 读目录"></a>16. 读目录</h2><h3 id="16-1-结构体dirent"><a href="#16-1-结构体dirent" class="headerlink" title="16.1 结构体dirent"></a>16.1 结构体<code>dirent</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">ino_t</span> d_ino;               <span class="hljs-comment">/* i-node number */</span><br>    <span class="hljs-type">char</span> d_name[NAME_MAX + <span class="hljs-number">1</span>]; <span class="hljs-comment">/* null-terminated filename */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><em>注：<code>NAME_MAX</code>依赖于文件系统</em></p><h3 id="16-2-opendir函数"><a href="#16-2-opendir函数" class="headerlink" title="16.2 opendir函数"></a>16.2 <code>opendir</code>函数</h3><h4 id="16-2-1-功能"><a href="#16-2-1-功能" class="headerlink" title="16.2.1 功能"></a>16.2.1 功能</h4><p>打开目录</p><h4 id="16-2-2-函数原型"><a href="#16-2-2-函数原型" class="headerlink" title="16.2.2 函数原型"></a>16.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回指针，出错返回NULL</span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-3-readdir函数"><a href="#16-3-readdir函数" class="headerlink" title="16.3 readdir函数"></a>16.3 <code>readdir</code>函数</h3><h4 id="16-3-1-功能"><a href="#16-3-1-功能" class="headerlink" title="16.3.1 功能"></a>16.3.1 功能</h4><p>读取目录每一项</p><h4 id="16-3-2-函数原型"><a href="#16-3-2-函数原型" class="headerlink" title="16.3.2 函数原型"></a>16.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回指针，出错或目录结尾返回NULL</span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dp)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-4-telldir函数"><a href="#16-4-telldir函数" class="headerlink" title="16.4 telldir函数"></a>16.4 <code>telldir</code>函数</h3><h4 id="16-4-1-功能"><a href="#16-4-1-功能" class="headerlink" title="16.4.1 功能"></a>16.4.1 功能</h4><p>获取当前目录流读取位置</p><h4 id="16-4-2-函数原型"><a href="#16-4-2-函数原型" class="headerlink" title="16.4.2 函数原型"></a>16.4.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">telldir</span><span class="hljs-params">(DIR *dp)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-5-rewinddir函数"><a href="#16-5-rewinddir函数" class="headerlink" title="16.5 rewinddir函数"></a>16.5 <code>rewinddir</code>函数</h3><h4 id="16-5-1-功能"><a href="#16-5-1-功能" class="headerlink" title="16.5.1 功能"></a>16.5.1 功能</h4><p>重置目录句柄，使得下次读取目录从头开始</p><h4 id="16-5-2-函数原型"><a href="#16-5-2-函数原型" class="headerlink" title="16.5.2 函数原型"></a>16.5.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rewinddir</span><span class="hljs-params">(DIR *dp)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-6-seekdir函数"><a href="#16-6-seekdir函数" class="headerlink" title="16.6 seekdir函数"></a>16.6 <code>seekdir</code>函数</h3><h4 id="16-6-1-功能"><a href="#16-6-1-功能" class="headerlink" title="16.6.1 功能"></a>16.6.1 功能</h4><p>设置目录流读取位置</p><h4 id="16-6-2-函数原型"><a href="#16-6-2-函数原型" class="headerlink" title="16.6.2 函数原型"></a>16.6.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seekdir</span><span class="hljs-params">(DIR *dp, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-7-closedir函数"><a href="#16-7-closedir函数" class="headerlink" title="16.7 closedir函数"></a>16.7 <code>closedir</code>函数</h3><h4 id="16-7-1-功能"><a href="#16-7-1-功能" class="headerlink" title="16.7.1 功能"></a>16.7.1 功能</h4><p>关闭处于打开状态的目录</p><h4 id="16-7-2-函数原型"><a href="#16-7-2-函数原型" class="headerlink" title="16.7.2 函数原型"></a>16.7.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br></code></pre></td></tr></table></figure><h2 id="17-chdir、fchdir和getcwd函数"><a href="#17-chdir、fchdir和getcwd函数" class="headerlink" title="17. chdir、fchdir和getcwd函数"></a>17. <code>chdir</code>、<code>fchdir</code>和<code>getcwd</code>函数</h2><h3 id="17-1-功能"><a href="#17-1-功能" class="headerlink" title="17.1 功能"></a>17.1 功能</h3><ul><li><code>chdir</code>和<code>fchdir</code>用来改变进程当前工作目录</li><li><code>getcwd</code>用来获取当前工作目录<strong>绝对路径</strong></li></ul><h3 id="17-2-函数原型"><a href="#17-2-函数原型" class="headerlink" title="17.2 函数原型"></a>17.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-comment">// 成功返回buf，出错返回NULL</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><h3 id="17-3-参数"><a href="#17-3-参数" class="headerlink" title="17.3 参数"></a>17.3 参数</h3><p><code>pathname</code>和<code>fd</code>用来指定新的当前工作目录</p><h2 id="18-文件的时间"><a href="#18-文件的时间" class="headerlink" title="18. 文件的时间"></a>18. 文件的时间</h2><h3 id="18-1-与文件相关的三个时间值"><a href="#18-1-与文件相关的三个时间值" class="headerlink" title="18.1 与文件相关的三个时间值"></a>18.1 与文件相关的三个时间值</h3><table><thead><tr><th align="center">字段</th><th align="center">说明</th><th align="center">可以修改此时间值的函数举例</th><th align="center">ls选项</th></tr></thead><tbody><tr><td align="center"><code>st_atime</code></td><td align="center">文件数据的最后访问（access）时间</td><td align="center"><code>read</code></td><td align="center">-u</td></tr><tr><td align="center"><code>st_mtime</code></td><td align="center">文件数据的最后修改（modify）时间</td><td align="center"><code>write</code></td><td align="center">默认</td></tr><tr><td align="center"><code>st_ctime</code></td><td align="center">i节点状态的最后更改（change）时间</td><td align="center"><code>chmod</code>、<code>chown</code></td><td align="center">-c</td></tr></tbody></table><p><em>注意：系统不保存对一个i节点的最后一次访问时间，因此<code>access</code>和<code>stat</code>函数并不更改这三个时间中任一个</em></p><h3 id="18-2-utime函数"><a href="#18-2-utime函数" class="headerlink" title="18.2 utime函数"></a>18.2 <code>utime</code>函数</h3><h4 id="18-2-1-功能"><a href="#18-2-1-功能" class="headerlink" title="18.2.1 功能"></a>18.2.1 功能</h4><p>更改文件的访问时间（atime）和修改时间（mtime）</p><h4 id="18-2-2-函数原型"><a href="#18-2-2-函数原型" class="headerlink" title="18.2.2 函数原型"></a>18.2.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utimbuf</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">time_t</span> actime;  <span class="hljs-comment">/* access time */</span><br>    <span class="hljs-type">time_t</span> modtime; <span class="hljs-comment">/* modification time */</span><br>&#125;;<br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">utime</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> utimbuf *times)</span>;<br></code></pre></td></tr></table></figure><h4 id="18-2-3-参数times"><a href="#18-2-3-参数times" class="headerlink" title="18.2.3 参数times"></a>18.2.3 参数<code>times</code></h4><ul><li><code>times</code>为空指针：atime和ctime均设置为当前时间。条件：进程的有效用户ID必须等于文件所有者ID；或者进程对文件具有写权限</li><li><code>times</code>为非空指针：atime和ctime均设置为结构体中的时间值。条件：进程的有效用户ID必须等于文件所有者ID；或者进程是一个超级用户进程</li></ul><h4 id="18-2-4-注意"><a href="#18-2-4-注意" class="headerlink" title="18.2.4 注意"></a>18.2.4 注意</h4><p>不能更改ctime为一个指定值，当调用<code>utime</code>函数时，此字段将被自动更新</p><h2 id="19-设备特殊文件"><a href="#19-设备特殊文件" class="headerlink" title="19. 设备特殊文件"></a>19. 设备特殊文件</h2><ul><li><code>st_dev</code>表示文件所在的设备的ID</li><li><code>st_rdev</code>是特殊文件（如字符特殊文件和块特殊文件）所代表的设备的设备号</li></ul>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keyword - register</title>
    <link href="/2023/10/02/keyword-register/"/>
    <url>/2023/10/02/keyword-register/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字—register"><a href="#关键字—register" class="headerlink" title="关键字—register"></a>关键字—<code>register</code></h1><h2 id="1-C语言存储期和链接"><a href="#1-C语言存储期和链接" class="headerlink" title="1. C语言存储期和链接"></a>1. C语言存储期和链接</h2><h3 id="1-1-存储期"><a href="#1-1-存储期" class="headerlink" title="1.1 存储期"></a>1.1 存储期</h3><p>即生存期，有四种：</p><ul><li>自动存储期：当一个对象在其所在的块中被声明时，会为其分配存储空间；而退出该块时，会释放其存储空间</li><li>静态存储期：对象的存储期贯穿整个程序的执行过程</li><li>线程存储期：对象的存储期贯穿整个线程的执行过程<em>（C11起）</em></li><li>分配存储期：使用动态内存分配函数来分配和释放存储空间</li></ul><h3 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h3><p>即可见性，有三种：</p><ul><li>无链接：标识符只能在其所在的作用域中被引用</li><li>内部链接：标识符可以在当前的翻译单元的所有作用域中被引用</li><li>外部链接：标识符可以在任何其他翻译单元的所有作用域中被引用</li></ul><h2 id="2-C语言存储类别说明符"><a href="#2-C语言存储类别说明符" class="headerlink" title="2. C语言存储类别说明符"></a>2. C语言存储类别说明符</h2><table><thead><tr><th align="center">关键字</th><th align="center">存储期</th><th align="center">链接</th></tr></thead><tbody><tr><td align="center"><code>auto</code></td><td align="center">自动</td><td align="center">无链接</td></tr><tr><td align="center"><code>extern</code></td><td align="center">静态</td><td align="center">外部链接</td></tr><tr><td align="center"><code>register</code></td><td align="center">自动</td><td align="center">无链接</td></tr><tr><td align="center"><code>static</code></td><td align="center">静态</td><td align="center">内部链接（块作用域下无链接）</td></tr><tr><td align="center"><code>_Thread_local</code><em>(C11起)</em></td><td align="center">线程</td><td align="center"></td></tr></tbody></table><h2 id="3-register的作用"><a href="#3-register的作用" class="headerlink" title="3. register的作用"></a>3. <code>register</code>的作用</h2><p><code>register</code>关键字建议编译器将变量存储在CPU寄存器以提高效率，但实际是否采纳这一建议由编译器自行决定</p><h2 id="4-C语言使用register注意事项"><a href="#4-C语言使用register注意事项" class="headerlink" title="4. C语言使用register注意事项"></a>4. C语言使用<code>register</code>注意事项</h2><ul><li>不能对寄存器变量进行取地址运算</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p = &amp;i; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><ul><li><code>register</code>关键字可以修饰指针变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> *p = &amp;i; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><ul><li>关键字 <code>register</code> 只能在局部作用域内和函数参数列表中使用，不能在全局作用域中使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//error</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> number)</span> <span class="hljs-comment">// OK</span><br>&#123;<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>register</code>是一个存储类别说明符，每个变量只能拥有一个存储类别说明符。因此，<code>register</code>关键字不能与<code>static</code>一同使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">register</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><ul><li>C程序虽然可以声明不限数量的寄存器变量，但编译器可能并不会把所有这些变量都存入寄存器中</li></ul><h2 id="5-C-register"><a href="#5-C-register" class="headerlink" title="5. C++register"></a>5. C++<code>register</code></h2><ul><li><p><strong>从C++17开始，虽然<code>register</code>关键词被保留，但在C++中不再使用</strong></p></li><li><p>在C++17之前，使用<code>register</code>关键字声明的对象与未带任何存储类说明符的变量在语义上没有区别（相当于C中的<code>auto</code>），并且可以用来提示优化器将该变量的值存储到CPU寄存器中</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// test.cpp</span><br><br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// error</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *p = &amp;j; <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Keyword</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keyword in C/C++ - volatile</title>
    <link href="/2023/10/01/keyword-volatile/"/>
    <url>/2023/10/01/keyword-volatile/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-关键字—volatile"><a href="#C-C-关键字—volatile" class="headerlink" title="C&#x2F;C++关键字—volatile"></a>C&#x2F;C++关键字—<code>volatile</code></h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p><code>volatile</code>是一种类型修饰符，它提醒编译器修饰的变量可能会随时更改，强制每次直接从内存读取，以避免不一致。如果省略<code>volatile</code>，编译器可能会优化读写操作，导致潜在不一致性问题，因为它可能使用暂存的寄存器值</p><h2 id="2-注意"><a href="#2-注意" class="headerlink" title="2. 注意"></a>2. 注意</h2><ul><li>欲使用<code>volatile</code>语义访问非<code>volatile</code>对象，必须先将其地址转换成指向<code>volatile</code>类型的指针，再通过该指针访问该对象</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *p = &amp;n;           <span class="hljs-comment">// warning</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *vp = &amp;n; <span class="hljs-comment">// no warning</span><br></code></pre></td></tr></table></figure><ul><li>指向非<code>volatile</code>类型的指针可以隐式转换成指向同一或兼容类型的<code>volatile</code>限定版本的指针。逆向转换可以由类型转换表达式进行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *vp = p; <span class="hljs-comment">// no warning</span><br>p = vp;               <span class="hljs-comment">// warning</span><br>p = (<span class="hljs-type">int</span> *)vp;        <span class="hljs-comment">// no warning</span><br></code></pre></td></tr></table></figure><ul><li><code>volatile </code>限定的结构体或联合体类型，其成员会获取其所属类型的限定（当通过<code> .</code> 或 <code>-&gt; </code>运算符时）：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci;<br>&#125; s;                  <span class="hljs-comment">// s.i类型是int，s.ci的类型是const int</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> <span class="hljs-title">vs</span>;</span> <span class="hljs-comment">// vs.i和vs.ci的类型各是volatile int和const volatile int</span><br></code></pre></td></tr></table></figure><ul><li>数组类型<ul><li>C23前：以<code>volatile</code>类型限定符声明数组类型（通过使用<code>typedef</code>），则数组类型无<code>volatile</code>限定，但其元素类型有</li><li>C23起：数组类型与其元素类型同等地拥有<code>volatile</code>限定</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> A[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">volatile</span> A a = &#123;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;&#125;; <span class="hljs-comment">// 元素类型为volatile int的二维数组</span><br><span class="hljs-type">int</span> *pi = a[<span class="hljs-number">0</span>];                        <span class="hljs-comment">// warning</span><br><span class="hljs-type">int</span> (*p)[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &amp;a;                   <span class="hljs-comment">// warning</span><br></code></pre></td></tr></table></figure><h2 id="3-const与volatile"><a href="#3-const与volatile" class="headerlink" title="3. const与volatile"></a>3. <code>const</code>与<code>volatile</code></h2><h3 id="3-1-含义"><a href="#3-1-含义" class="headerlink" title="3.1 含义"></a>3.1 含义</h3><ul><li><code>const</code> 表示“<strong>请将其视为常量使用</strong>”，而不是“这肯定是个常量”</li><li><code>volatile</code> 表示“<strong>请不要进行自以为是的优化，这个值可能会改变</strong>”，而不是“你可以修改这个值”</li></ul><h3 id="3-2-作用及阶段"><a href="#3-2-作用及阶段" class="headerlink" title="3.2 作用及阶段"></a>3.2 作用及阶段</h3><ul><li><code>const</code> 仅在编译期间有效，在源代码中保证该变量不会被修改。但在运行时，该变量的值是否被改变并不受 <code>const</code> 限制</li><li><code>volatile</code> 在编译期和运行期均有效。在编译期，它告诉编译器不要进行优化，变量的值可能随时改变。在运行期，每次使用该变量的值时，都会直接从内存中取得最新值</li></ul><h3 id="3-3-搭配使用"><a href="#3-3-搭配使用" class="headerlink" title="3.3 搭配使用"></a>3.3 搭配使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_ADDRESS 0x40025000 <span class="hljs-comment">// 假设有一个硬件寄存器的地址是0x40025000</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *register_ptr = (<span class="hljs-type">uint32_t</span> *)REGISTER_ADDRESS; <span class="hljs-comment">// 使用const和volatile来定义一个指向该寄存器的指针</span><br></code></pre></td></tr></table></figure><h2 id="4-用法"><a href="#4-用法" class="headerlink" title="4. 用法"></a>4. 用法</h2><ul><li><code>static volatile</code>模拟内存映射的I&#x2F;O端口，<code>static const volatile</code>模拟只读的输入端口</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> io_port; <span class="hljs-comment">// 模拟内存映射的I/O端口</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> input_port; <span class="hljs-comment">// 模拟只读的输入端口</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_to_io_port</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> value)</span><br>&#123;<br>    io_port = value; <span class="hljs-comment">// 写入I/O端口</span><br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">read_from_input_port</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> input_port; <span class="hljs-comment">// 从输入端口读取</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>volatile</code>保证<code>longjmp</code>后恢复局部变量的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br>jmp_buf env;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span><br>&#123;<br>    longjmp(env, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (setjmp(env))<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After longjmp: r = %d, v = %d\n&quot;</span>, r, v);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        r = v = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before longjmp: r = %d, v = %d\n&quot;</span>, r, v);<br>        func();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs BASH">$ gcc -O3 test.c<br>$ ./a.out<br>Before longjmp: r = 1, v = 1<br>After longjmp: r = 0, v = 1<br></code></pre></td></tr></table></figure><p><code>setjmp</code>函数负责保存程序的执行环境，包括寄存器中的值。<code>volatile</code>关键字则保证变量的值始终在内存中进行读写，而不是在寄存器中。这意味着，在使用<code>longjmp</code>进行非局部跳转后，<code>volatile</code>变量的值将恢复为调用<code>longjmp</code>之前的最新值，而不是在调用<code>setjmp</code>时的值</p><p>正如上述程序运行结果所示，<code>register</code>变量恢复了调用<code>setjmp</code>时的值，而<code>volatile</code>变量则恢复了调用<code>longjmp</code>前的最新值</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Keyword</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 07 - Process Environment</title>
    <link href="/2023/09/29/apue-ch07/"/>
    <url>/2023/09/29/apue-ch07/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-07-进程环境"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-07-进程环境" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 07  进程环境"></a>Advanced Programming in the UNIX Environment—Chapter 07  进程环境</h1><h2 id="1-进程终止"><a href="#1-进程终止" class="headerlink" title="1. 进程终止"></a>1. 进程终止</h2><h3 id="1-1-进程终止方式"><a href="#1-1-进程终止方式" class="headerlink" title="1.1 进程终止方式"></a>1.1 进程终止方式</h3><h4 id="1-1-1-正常终止"><a href="#1-1-1-正常终止" class="headerlink" title="1.1.1 正常终止"></a>1.1.1 正常终止</h4><ul><li><code>main</code>返回</li><li>调用<code>exit</code></li><li>调用<code>_exit</code>或<code>_Exit</code></li><li>最后一个线程从启动例程返回</li><li>最后一个线程调用<code>pthread_exit</code></li></ul><h4 id="1-1-2-异常终止"><a href="#1-1-2-异常终止" class="headerlink" title="1.1.2 异常终止"></a>1.1.2 异常终止</h4><ul><li>调用<code>abort</code></li><li>接到一个信号并终止</li><li>最后一个线程对取消请求做出响应</li></ul><h3 id="1-2-exit、-exit和-Exit函数"><a href="#1-2-exit、-exit和-Exit函数" class="headerlink" title="1.2 exit、_exit和_Exit函数"></a>1.2 <code>exit</code>、<code>_exit</code>和<code>_Exit</code>函数</h3><h4 id="1-2-1-函数原型"><a href="#1-2-1-函数原型" class="headerlink" title="1.2.1 函数原型"></a>1.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><span class="hljs-type">void</span> _Exit(<span class="hljs-type">int</span> status);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);<br></code></pre></td></tr></table></figure><h4 id="1-2-2-区别"><a href="#1-2-2-区别" class="headerlink" title="1.2.2 区别"></a>1.2.2 区别</h4><ul><li><code>exit</code><ul><li>ISO C</li><li>终止程序前<strong>执行清理</strong>任务，关闭I&#x2F;O，刷新流，调用<code>atexit</code>中注册的函数</li></ul></li><li><code>_exit</code><ul><li>POSIX</li><li>直接进入内核，关闭打开的文件描述符，不刷新流，不调用<code>atexit</code>中注册的函数</li></ul></li><li><code>_Exit</code><ul><li>ISO C</li><li>等价于<code>_exit</code>（Linux下）</li></ul></li></ul><h3 id="1-3-atexit函数"><a href="#1-3-atexit函数" class="headerlink" title="1.3 atexit函数"></a>1.3 <code>atexit</code>函数</h3><h4 id="1-3-1-功能"><a href="#1-3-1-功能" class="headerlink" title="1.3.1 功能"></a>1.3.1 功能</h4><p>注册程序<strong>正常终止</strong>时执行的函数。<code>atexit</code> 函数可以多次调用，以注册多个退出处理函数，这些函数将按照注册的顺序逆序执行</p><h4 id="1-3-2-函数原型"><a href="#1-3-2-函数原型" class="headerlink" title="1.3.2 函数原型"></a>1.3.2 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>))</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-C程序启动和终止"><a href="#1-3-3-C程序启动和终止" class="headerlink" title="1.3.3 C程序启动和终止"></a>1.3.3 C程序启动和终止</h4><p><img src="/2023/09/29/apue-ch07/c_startup_termination.png" alt="C程序的启动和终止"></p><h2 id="2-环境表"><a href="#2-环境表" class="headerlink" title="2. 环境表"></a>2. 环境表</h2><h3 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br></code></pre></td></tr></table></figure><h3 id="2-2-类型"><a href="#2-2-类型" class="headerlink" title="2.2 类型"></a>2.2 类型</h3><ul><li><strong>全局变量</strong></li><li>字符指针数组（每个字符指针指向以null字符结尾的字符串，字符串格式：<em>name&#x3D;value</em>）</li></ul><p><img src="/2023/09/29/apue-ch07/environ.png" alt="5个C字符串组成的环境表"></p><h3 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h3><ul><li>每个程序都会接收到一张环境表</li><li>查看整个环境，使用<code>environ</code>指针；用<code>getenv</code>和<code>putenv</code>函数访问和修改特定环境变量</li></ul><h2 id="3-C程序的存储空间布局"><a href="#3-C程序的存储空间布局" class="headerlink" title="3. C程序的存储空间布局"></a>3. C程序的存储空间布局</h2><p><img src="/2023/09/29/apue-ch07/memory_arrangement.png" alt="典型的存储器安排"></p><h2 id="4-共享库"><a href="#4-共享库" class="headerlink" title="4. 共享库"></a>4. 共享库</h2><h3 id="4-1-优缺点"><a href="#4-1-优缺点" class="headerlink" title="4.1 优缺点"></a>4.1 优缺点</h3><ul><li>优点<ul><li>可执行文件体积较小</li><li>易于维护</li></ul></li><li>缺点<ul><li>运行效率低</li><li>依赖于库</li></ul></li></ul><h2 id="5-存储器分配"><a href="#5-存储器分配" class="headerlink" title="5. 存储器分配"></a>5. 存储器分配</h2><h3 id="5-1-功能"><a href="#5-1-功能" class="headerlink" title="5.1 功能"></a>5.1 功能</h3><ul><li><code>malloc</code>：分配指定字节数的存储区，初始值不确定</li><li><code>calloc</code>：为<strong>指定数量</strong>具有<strong>指定长度</strong>的对象分配存储空间，该空间<strong>每一位初始化为0</strong></li><li><code>realloc</code>：更改分配区长度。当增加分配区长度时，可能将先前分配的内容移动到另一个足够大的区域，以便在尾端提供增加的存储区，新增区域初始值不确定</li><li><code>free</code>：释放<code>malloc</code>、<code>calloc</code>和<code>realloc</code>分配的内存块</li></ul><h3 id="5-2-函数原型"><a href="#5-2-函数原型" class="headerlink" title="5.2 函数原型"></a>5.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回非空指针，出错返回NULL</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nobj, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> newsize)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-3-注意"><a href="#5-3-注意" class="headerlink" title="5.3 注意"></a>5.3 注意</h3><ul><li><strong><code>malloc</code>、<code>calloc</code>和<code>realloc</code>返回的指针一定是对齐的</strong></li><li>大多数实现中，实际分配的存储空间比请求的空间稍大，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针</li></ul><h2 id="6-环境变量"><a href="#6-环境变量" class="headerlink" title="6. 环境变量"></a>6. 环境变量</h2><h3 id="6-1-getenv函数"><a href="#6-1-getenv函数" class="headerlink" title="6.1 getenv函数"></a>6.1 <code>getenv</code>函数</h3><h4 id="6-1-1-函数原型"><a href="#6-1-1-函数原型" class="headerlink" title="6.1.1 函数原型"></a>6.1.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-返回值"><a href="#6-1-2-返回值" class="headerlink" title="6.1.2 返回值"></a>6.1.2 返回值</h4><p>返回一个指针，指向<em>name&#x3D;value</em>字符串中的<em>value</em></p><h4 id="6-1-3-示例"><a href="#6-1-3-示例" class="headerlink" title="6.1.3 示例"></a>6.1.3 示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> *pHome = getenv(<span class="hljs-string">&quot;HOME&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HOME=%s\n&quot;</span>, pHome);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// HOME=/root</span><br></code></pre></td></tr></table></figure><h3 id="6-2-putenv函数"><a href="#6-2-putenv函数" class="headerlink" title="6.2 putenv函数"></a>6.2 <code>putenv</code>函数</h3><h4 id="6-2-1-函数原型"><a href="#6-2-1-函数原型" class="headerlink" title="6.2.1 函数原型"></a>6.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putenv</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-功能"><a href="#6-2-2-功能" class="headerlink" title="6.2.2 功能"></a>6.2.2 功能</h4><p>取形式为<em>name&#x3D;env</em>的字符串，将其放到环境表中。如果<em>name</em>已经存在，则先删除原定义</p><h3 id="6-3-setenv函数"><a href="#6-3-setenv函数" class="headerlink" title="6.3 setenv函数"></a>6.3 <code>setenv</code>函数</h3><h4 id="6-3-1-函数原型"><a href="#6-3-1-函数原型" class="headerlink" title="6.3.1 函数原型"></a>6.3.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value, <span class="hljs-type">int</span> rewrite)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-2-功能"><a href="#6-3-2-功能" class="headerlink" title="6.3.2 功能"></a>6.3.2 功能</h4><p>将<code>name</code>设置为<code>value</code>，若<code>name</code>已存在，那么</p><ul><li><code>rewrite</code>非0：删除现有定义（<code>name</code>设置为<code>value</code>）</li><li><code>rewrite</code>为0：不删除现有定义（<code>name</code>不设置为<code>value</code>，而且也不算出错）</li></ul><h3 id="6-4-unsetenv函数"><a href="#6-4-unsetenv函数" class="headerlink" title="6.4 unsetenv函数"></a>6.4 <code>unsetenv</code>函数</h3><h4 id="6-4-1-函数原型"><a href="#6-4-1-函数原型" class="headerlink" title="6.4.1 函数原型"></a>6.4.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">unsetenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-4-2-功能"><a href="#6-4-2-功能" class="headerlink" title="6.4.2 功能"></a>6.4.2 功能</h4><p>删除<code>name</code>的定义，即使<code>name</code>不存在也不算出错</p><h2 id="7-setjmp和longjmp函数"><a href="#7-setjmp和longjmp函数" class="headerlink" title="7. setjmp和longjmp函数"></a>7. <code>setjmp</code>和<code>longjmp</code>函数</h2><h3 id="7-1-setjmp"><a href="#7-1-setjmp" class="headerlink" title="7.1 setjmp"></a>7.1 <code>setjmp</code></h3><h4 id="7-1-1-原型"><a href="#7-1-1-原型" class="headerlink" title="7.1.1 原型"></a>7.1.1 原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-comment">// 直接调用返回0</span><br><span class="hljs-comment">// 从longjmp调用返回则返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br></code></pre></td></tr></table></figure><h4 id="7-1-2-功能"><a href="#7-1-2-功能" class="headerlink" title="7.1.2 功能"></a>7.1.2 功能</h4><p>保存当前程序状态（堆栈指针、寄存器等信息）到<code>env</code>中</p><h3 id="7-2-longjmp"><a href="#7-2-longjmp" class="headerlink" title="7.2 longjmp"></a>7.2 <code>longjmp</code></h3><h4 id="7-2-1-函数原型"><a href="#7-2-1-函数原型" class="headerlink" title="7.2.1 函数原型"></a>7.2.1 函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_buf env, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure><h4 id="7-2-2-功能"><a href="#7-2-2-功能" class="headerlink" title="7.2.2 功能"></a>7.2.2 功能</h4><p>恢复最近一次调用<code>setjmp</code>时保存的程序状态，并使得<code>setjmp</code>返回<code>val</code></p><h3 id="7-3-使用场景"><a href="#7-3-使用场景" class="headerlink" title="7.3 使用场景"></a>7.3 使用场景</h3><ul><li>错误处理：深层嵌套中发生了错误</li><li>协程</li></ul><h2 id="8-getrlimit和setrlimit函数"><a href="#8-getrlimit和setrlimit函数" class="headerlink" title="8. getrlimit和setrlimit函数"></a>8. <code>getrlimit</code>和<code>setrlimit</code>函数</h2><h3 id="8-1-功能"><a href="#8-1-功能" class="headerlink" title="8.1 功能"></a>8.1 功能</h3><p>获取和更改进程资源限制</p><h3 id="8-2-函数原型"><a href="#8-2-函数原型" class="headerlink" title="8.2 函数原型"></a>8.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">rlim_t</span> rlim_cur; <span class="hljs-comment">/* soft limit: current limit */</span><br>    <span class="hljs-type">rlim_t</span> rlim_max; <span class="hljs-comment">/* hard limit: maximum value for rlim_cur */</span><br>&#125;;<br><br><span class="hljs-comment">// 成功返回0，出错返回非0值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getrlimit</span><span class="hljs-params">(<span class="hljs-type">int</span> resource, <span class="hljs-keyword">struct</span> rlimit *rlptr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setrlimit</span><span class="hljs-params">(<span class="hljs-type">int</span> resource, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> rlimit *rlptr)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-3-更改资源限制的规则"><a href="#8-3-更改资源限制的规则" class="headerlink" title="8.3 更改资源限制的规则"></a>8.3 更改资源限制的规则</h3><ul><li>软限制值小于等于硬限制值</li><li>可降低硬限制值，但硬限制值必须大于等于软限制值</li><li>只有超级用户可以提高硬限制值</li></ul><h3 id="8-4-参数resource"><a href="#8-4-参数resource" class="headerlink" title="8.4 参数resource"></a>8.4 参数<code>resource</code></h3><table><thead><tr><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>RLIMIT_AS</code></td><td align="center">进程可用存储区的最大总长度（字节）</td></tr><tr><td align="center"><code>RLIMIT_CORE</code></td><td align="center">core文件的最大字节数，为0时阻止创建core文件</td></tr><tr><td align="center"><code>RLIMIT_CPU</code></td><td align="center">CPU时间最大量值（秒），超过此软限制时，向该进程发送<code>SIGXCPU</code>信号</td></tr><tr><td align="center"><code>RLIMIT_DATA</code></td><td align="center">数据段最大字节长度</td></tr><tr><td align="center"><code>RLIMIT_FSIZE</code></td><td align="center">可以创建的文件的最大字节长度，超过此软限制时，向该进程发送<code>SIGXFSZ</code>信号</td></tr><tr><td align="center"><code>RLIMIT_LOCKS</code></td><td align="center">一个进程可以持有的文件锁的最大数</td></tr><tr><td align="center"><code>RLIMIT_MEMLOCK</code></td><td align="center">一个进程使用<code>mlock</code>能够锁定在存储器中的最大字节长度</td></tr><tr><td align="center"><code>RLIMIT_NOFILE</code></td><td align="center">一个进程可以打开的最大文件数</td></tr><tr><td align="center"><code>RLIMIT_NPROC</code></td><td align="center">每个实际用户ID可拥有的最大子进程数</td></tr><tr><td align="center"><code>RLIMIT_RSS</code></td><td align="center">最大驻内存集的字节长度</td></tr><tr><td align="center"><code>RLIMIT_SBSIZE</code></td><td align="center">用户在任一给定时刻可以占用的套接字缓冲区的最大长度</td></tr><tr><td align="center"><code>RLIMIT_STACK</code></td><td align="center">栈的最大字节长度</td></tr><tr><td align="center"><code>RLIMIT_VMEM</code></td><td align="center">等价于<code>RLIMIT_AS</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Singleton Pattern</title>
    <link href="/2023/09/27/singleton-pattern/"/>
    <url>/2023/09/27/singleton-pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="C-单例模式"><a href="#C-单例模式" class="headerlink" title="C++ 单例模式"></a>C++ 单例模式</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 加入锁，确保线程安全</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mutex</span>();<br>    ~<span class="hljs-built_in">Mutex</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// singleton.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroyInstance</span><span class="hljs-params">()</span></span>;<br>...<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L <span class="hljs-comment">// C++11及以后</span></span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(Singleton &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 拷贝构造函数和拷贝赋值运算符声明在private段，不可定义</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;);<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数和析构函数必须声明在private段，且必须在源文件中实现</span><br><span class="hljs-comment">     * 构造函数和析构函数不能被定义为删除的函数，因为需要在类其他函数中new和delete指向本类对象的指针</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Singleton</span>();<br>    ~<span class="hljs-built_in">Singleton</span>();<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton *instance_ptr;<br>    <span class="hljs-type">static</span> Mutex mutex;<br>&#125;;<br><br><span class="hljs-comment">// 静态非常量成员必须类外初始化</span><br>Singleton *Singleton::instance_ptr = <span class="hljs-literal">nullptr</span>;<br>Mutex Singleton::mutex;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// singleton.cpp</span><br><span class="hljs-function">Singleton *<span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == instance_ptr)<br>    &#123;<br>        mutex.<span class="hljs-built_in">request</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == instance_ptr) <span class="hljs-comment">// 两个if语句实现双重检查锁定模式</span><br>            instance_ptr = <span class="hljs-keyword">new</span> Singleton;<br>        mutex.<span class="hljs-built_in">release</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Singleton::destroyInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != instance_ptr)<br>    &#123;<br>        mutex.<span class="hljs-built_in">request</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != instance_ptr)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> instance_ptr;<br>            instance_ptr = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        mutex.<span class="hljs-built_in">release</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;singleton.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Singleton *si_ptr = Singleton::<span class="hljs-built_in">getInstance</span>();<br>    ...<br>    si_ptr-&gt;<span class="hljs-built_in">destroyInstance</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Programming Techniques</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APUE Chapter 03 - File I/O</title>
    <link href="/2023/09/23/apue-ch03/"/>
    <url>/2023/09/23/apue-ch03/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Programming-in-the-UNIX-Environment—Chapter-03-文件I-O"><a href="#Advanced-Programming-in-the-UNIX-Environment—Chapter-03-文件I-O" class="headerlink" title="Advanced Programming in the UNIX Environment—Chapter 03 文件I&#x2F;O"></a>Advanced Programming in the UNIX Environment—Chapter 03 文件I&#x2F;O</h1><h2 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h2><h3 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1 类型"></a>1.1 类型</h3><p>非负整数</p><h3 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h3><p>文件描述符在内核中用于引用所有打开的文件</p><h3 id="1-3-惯例"><a href="#1-3-惯例" class="headerlink" title="1.3 惯例"></a>1.3 惯例</h3><table><thead><tr><th align="center">常量</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>STDIN_FILENO</code></td><td align="center">0</td><td align="center">标准输入</td></tr><tr><td align="center"><code>STDOUT_FILENO</code></td><td align="center">1</td><td align="center">标准输出</td></tr><tr><td align="center"><code>STDERR_FILENO</code></td><td align="center">2</td><td align="center">标准错误输出</td></tr></tbody></table><p><em>注意：常量<code>STDIN_FILENO</code> <code>STDOUT_FILENO</code> <code>STDERR_FILENO</code>定义在头文件<code>&lt;unistd.h&gt;</code>中</em></p><h2 id="2-open函数"><a href="#2-open函数" class="headerlink" title="2. open函数"></a>2. <code>open</code>函数</h2><h3 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h3><p>打开或创建一个文件</p><h3 id="2-2-函数原型"><a href="#2-2-函数原型" class="headerlink" title="2.2 函数原型"></a>2.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回文件描述符，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> oflag, ... <span class="hljs-comment">/* mode_t mode */</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-参数oflag"><a href="#2-3-参数oflag" class="headerlink" title="2.3 参数oflag"></a>2.3 参数<code>oflag</code></h3><h4 id="2-3-1-必选且唯一指定"><a href="#2-3-1-必选且唯一指定" class="headerlink" title="2.3.1 必选且唯一指定"></a>2.3.1 必选且唯一指定</h4><ul><li><code>O_RDONLY</code>：只读打开</li><li><code>O_WRONLY</code>：只写打开</li><li><code>O_RDWR</code>：读写打开</li></ul><h4 id="2-3-2-可选"><a href="#2-3-2-可选" class="headerlink" title="2.3.2 可选"></a>2.3.2 可选</h4><ul><li><code>O_APPEND</code>：追加写</li><li><code>O_CREAT</code>：若文件不存在，则创建</li><li><code>O_EXCL</code>：若同时指定了<code>O_CREAT</code>，文件存在则出错，文件不存在则创建</li><li><code>O_TRUNC</code>：如果文件已存在，则截断文件的长度为零</li><li><code>O_NOCTTY</code>：如果<code>pathname</code>是终端设备，则不将此设备分配为此进程的控制终端</li><li><code>O_NONBLOCK</code>：非阻塞</li></ul><h4 id="2-3-3-其他"><a href="#2-3-3-其他" class="headerlink" title="2.3.3 其他"></a>2.3.3 其他</h4><ul><li><code>O_SYNC</code>：等待写完成（数据和属性）</li><li><code>O_DSYNC</code>：等待写完成（仅数据）</li><li><code>O_RSYNC</code>：同步读写</li><li>……</li></ul><h3 id="2-4-参数mode"><a href="#2-4-参数mode" class="headerlink" title="2.4 参数mode"></a>2.4 参数<code>mode</code></h3><p>只有参数<code>oflag</code>为<code>O_CREAT</code>时才可设置此参数</p><h4 id="2-4-1-作用"><a href="#2-4-1-作用" class="headerlink" title="2.4.1 作用"></a>2.4.1 作用</h4><p>该参数用于设置文件访问权限的初始值，和用户掩码<code>umask</code>有关</p><h4 id="2-4-2-参数形式"><a href="#2-4-2-参数形式" class="headerlink" title="2.4.2 参数形式"></a>2.4.2 参数形式</h4><ul><li>八进制数：如0777（rwxrwxrwx）</li><li>预定义宏的位操作：如<code>S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH</code>（rw-rw-r–）</li></ul><h3 id="2-5-文件名和路径名截断"><a href="#2-5-文件名和路径名截断" class="headerlink" title="2.5 文件名和路径名截断"></a>2.5 文件名和路径名截断</h3><h2 id="3-creat函数"><a href="#3-creat函数" class="headerlink" title="3. creat函数"></a>3. <code>creat</code>函数</h2><h3 id="3-1-功能"><a href="#3-1-功能" class="headerlink" title="3.1 功能"></a>3.1 功能</h3><p>创建文件</p><h3 id="3-2-函数原型"><a href="#3-2-函数原型" class="headerlink" title="3.2 函数原型"></a>3.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回为只写打开的文件描述符，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-等价形式"><a href="#3-3-等价形式" class="headerlink" title="3.3 等价形式"></a>3.3 等价形式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);<br></code></pre></td></tr></table></figure><h3 id="3-4-不足之处"><a href="#3-4-不足之处" class="headerlink" title="3.4 不足之处"></a>3.4 不足之处</h3><p><strong>只写打开</strong>所创建的文件</p><h2 id="4-close函数"><a href="#4-close函数" class="headerlink" title="4. close函数"></a>4. <code>close</code>函数</h2><h3 id="4-1-功能"><a href="#4-1-功能" class="headerlink" title="4.1 功能"></a>4.1 功能</h3><p>关闭打开的文件</p><h3 id="4-2-函数原型"><a href="#4-2-函数原型" class="headerlink" title="4.2 函数原型"></a>4.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure><h2 id="5-lseek函数"><a href="#5-lseek函数" class="headerlink" title="5. lseek函数"></a>5. <code>lseek</code>函数</h2><h3 id="5-1-功能"><a href="#5-1-功能" class="headerlink" title="5.1 功能"></a>5.1 功能</h3><p>设置文件读写指针的位置</p><h3 id="5-2-函数原型"><a href="#5-2-函数原型" class="headerlink" title="5.2 函数原型"></a>5.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回新的文件偏移量，出错返回-1</span><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-3-参数whence"><a href="#5-3-参数whence" class="headerlink" title="5.3 参数whence"></a>5.3 参数<code>whence</code></h3><ul><li><code>SEEK_SET</code>：文件开头</li><li><code>SEEK_CUR</code>：当前位置</li><li><code>SEEK_END</code>：文件末尾</li></ul><h2 id="6-read函数"><a href="#6-read函数" class="headerlink" title="6. read函数"></a>6. <code>read</code>函数</h2><h3 id="6-1-功能"><a href="#6-1-功能" class="headerlink" title="6.1 功能"></a>6.1 功能</h3><p>从打开文件中读数据</p><h3 id="6-2-函数原型"><a href="#6-2-函数原型" class="headerlink" title="6.2 函数原型"></a>6.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回读到的字节数，到文件结尾返回0，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br></code></pre></td></tr></table></figure><h2 id="7-write函数"><a href="#7-write函数" class="headerlink" title="7. write函数"></a>7. <code>write</code>函数</h2><h3 id="7-1-功能"><a href="#7-1-功能" class="headerlink" title="7.1 功能"></a>7.1 功能</h3><p>向打开的文件写数据</p><h3 id="7-2-函数原型"><a href="#7-2-函数原型" class="headerlink" title="7.2 函数原型"></a>7.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回已写的字节数，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br></code></pre></td></tr></table></figure><h2 id="8-文件共享"><a href="#8-文件共享" class="headerlink" title="8. 文件共享"></a>8. 文件共享</h2><h3 id="8-1-数据结构"><a href="#8-1-数据结构" class="headerlink" title="8.1 数据结构"></a>8.1 数据结构</h3><h4 id="8-1-1-进程表"><a href="#8-1-1-进程表" class="headerlink" title="8.1.1 进程表"></a>8.1.1 进程表</h4><ul><li>位置：内核空间</li></ul><h4 id="8-1-2-打开文件描述符表"><a href="#8-1-2-打开文件描述符表" class="headerlink" title="8.1.2 打开文件描述符表"></a>8.1.2 打开文件描述符表</h4><ul><li>位置：进程表项<em>（不一定在进程表中）</em></li><li>文件描述符表项包含<ul><li>文件描述符标志<em>（如<code>FD_CLOEXEC</code>）</em></li><li>文件表项指针</li></ul></li></ul><h4 id="8-1-3-文件表"><a href="#8-1-3-文件表" class="headerlink" title="8.1.3 文件表"></a>8.1.3 文件表</h4><ul><li><strong>内核</strong>为所有<strong>打开文件</strong>维护<strong>一张文件表</strong></li><li>文件表项包含<ul><li>文件状态标志（读、写、追加写、同步、阻塞等）</li><li>文件偏移量</li><li>指向v节点表项的指针</li></ul></li></ul><h4 id="8-1-4-v节点表"><a href="#8-1-4-v节点表" class="headerlink" title="8.1.4 v节点表"></a>8.1.4 v节点表</h4><ul><li>V节点包含<ul><li>文件类型</li><li>各种操作的函数指针</li><li>i节点</li></ul></li><li>i节点包含<ul><li>所有者</li><li>文件长度</li><li>文件所在设备</li><li>指向文件实际数据块在磁盘上所在位置的指针</li><li>……</li></ul></li></ul><p><img src="/2023/09/23/apue-ch03/file_share.png" alt="文件共享"></p><h3 id="8-2-两独立进程打开同一文件"><a href="#8-2-两独立进程打开同一文件" class="headerlink" title="8.2 两独立进程打开同一文件"></a>8.2 两独立进程打开同一文件</h3><p>两进程获得<strong>不同的文件描述符</strong>，但指向相同的v节点表项，因为这样能确保每个进程都有自己的对该文件的当前偏移量</p><p><img src="/2023/09/23/apue-ch03/open_same_file.png" alt="两独立进程打开同一文件"></p><h2 id="9-原子操作"><a href="#9-原子操作" class="headerlink" title="9. 原子操作"></a>9. 原子操作</h2><h3 id="9-1-函数原型"><a href="#9-1-函数原型" class="headerlink" title="9.1 函数原型"></a>9.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回读到的字节数，读到文件结尾返回0；出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">pread</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">// 成功返回已写的字节数，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">pwrite</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><h3 id="9-2-特点"><a href="#9-2-特点" class="headerlink" title="9.2 特点"></a>9.2 特点</h3><p><code>pread</code>相当于顺序调用<code>lseek</code>和<code>read</code>，但是<code>pread</code>不可被中断，且<strong>不更新文件指针</strong></p><p><code>pwrite</code>同理</p><h2 id="10-dup和dup2函数"><a href="#10-dup和dup2函数" class="headerlink" title="10. dup和dup2函数"></a>10. <code>dup</code>和<code>dup2</code>函数</h2><h3 id="10-1-功能"><a href="#10-1-功能" class="headerlink" title="10.1 功能"></a>10.1 功能</h3><p>复制<strong>现存</strong>的文件描述符</p><h3 id="10-2-函数原型"><a href="#10-2-函数原型" class="headerlink" title="10.2 函数原型"></a>10.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回新的文件描述符，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)</span>;<br></code></pre></td></tr></table></figure><h3 id="10-3-返回值"><a href="#10-3-返回值" class="headerlink" title="10.3 返回值"></a>10.3 返回值</h3><ul><li><code>dup</code>返回文件描述符一定是<strong>可用文件描述符的最小值</strong></li><li><code>dup2</code>可用<code>fd2</code>指定新描述符。如果<code>fd2</code>已经打开，则先将其关闭；如果<code>fd == fd2</code>，则<code>dup2</code>返回<code>fd2</code>，不关闭</li></ul><h3 id="10-4-dup2的原子性"><a href="#10-4-dup2的原子性" class="headerlink" title="10.4 dup2的原子性"></a>10.4 <code>dup2</code>的原子性</h3><p><code>dup2</code>函数等价如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">close(fd2);<br>fcntl(fd, F_DUPFD, fd2);<br></code></pre></td></tr></table></figure><p>但<code>dup2</code>是原子操作，不会被中断</p><h2 id="11-sync-fsync和fdatasync函数"><a href="#11-sync-fsync和fdatasync函数" class="headerlink" title="11. sync fsync和fdatasync函数"></a>11. <code>sync</code> <code>fsync</code>和<code>fdatasync</code>函数</h2><h3 id="11-1-背景"><a href="#11-1-背景" class="headerlink" title="11.1 背景"></a>11.1 背景</h3><p>延迟写策略<em>（减少磁盘读写次数，降低了文件内容的更新速度）</em></p><h3 id="11-2-函数原型"><a href="#11-2-函数原型" class="headerlink" title="11.2 函数原型"></a>11.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回0，出错返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fdatasync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="11-3-效果"><a href="#11-3-效果" class="headerlink" title="11.3 效果"></a>11.3 效果</h3><ul><li><code>sync</code>函数将修改过的缓冲区排入写队列，然后返回，并不等待实际写操作结束。<em>守护进程<code>update</code>和命令<code>sync</code>也调用<code>sync</code>函数</em></li><li><code>fsync</code>函数只对<code>fd</code>指定的单一文件起作用，并且等待磁盘写操作结束。<em>除数据外，<code>fsync</code>还会更新文件的属性</em></li><li><code>fdatasync</code>只影响文件的数据部分</li></ul><h2 id="12-fcntl函数"><a href="#12-fcntl函数" class="headerlink" title="12. fcntl函数"></a>12. <code>fcntl</code>函数</h2><h3 id="12-1-函数原型"><a href="#12-1-函数原型" class="headerlink" title="12.1 函数原型"></a>12.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 成功返回值依赖于cmd，</span><br><span class="hljs-comment">// 出错均返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* int arg */</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="12-2-功能（即参数cmd）"><a href="#12-2-功能（即参数cmd）" class="headerlink" title="12.2 功能（即参数cmd）"></a>12.2 功能（即参数<code>cmd</code>）</h3><ul><li><p><code>F_DUPFD</code></p><ul><li>复制文件描述符</li><li>返回值：新文件描述符</li></ul></li><li><p><code>F_GETFD</code>：获取文件描述符标志</p></li><li><p><code>F_SETFD</code>：设置文件描述符标志</p></li><li><p><code>F_GETFL</code>：获取文件状态标志<em>（即<code>open</code>函数的<code>oflag</code>）</em></p></li><li><p><code>F_SETFL</code>：根据参数<code>arg</code>设置文件描述符标志</p></li><li><p><code>F_GETOWN</code>：获取接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID</p></li><li><p><code>F_SETOWN</code></p><ul><li>根据<code>arg</code>设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID</li><li><code>arg &gt; 0</code>时指定进程ID</li><li><code>arg &lt; 0</code>时指定进程组ID（进程组ID为<code>arg</code>的绝对值）</li></ul></li><li><p><code>F_GETLK</code>、<code>F_SETLK</code>或<code>F_SETLKW</code>：获得&#x2F;设置记录锁</p></li></ul><table><thead><tr><th align="center">概念</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">文件描述符标志</td><td align="center">体现文件描述符的状态，目前只有一种：<code>FD_CLOEXEC</code></td></tr><tr><td align="center">文件状态标志</td><td align="center">体现进程打开的文件的一些标志</td></tr></tbody></table><h3 id="12-3-实例：修改文件状态标志"><a href="#12-3-实例：修改文件状态标志" class="headerlink" title="12.3 实例：修改文件状态标志"></a>12.3 实例：修改文件状态标志</h3><p><strong>若需要修改文件状态标志，先需要取得现有标志，然后根据需要进行修改，最后设置新标志。不能只是执行<code>F_SETFD</code>或<code>F_SETFL</code>命令，这样可能会关闭以前设置的标志位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">set_fl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags)</span> <span class="hljs-comment">// flags are file status flags to turn on</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fcntl F_GETFL error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    val |= flags; <span class="hljs-comment">// turn on flags</span><br><br>    <span class="hljs-keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fcntl F_SETFL error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clr_fl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags)</span> <span class="hljs-comment">// flags are file status flags to turn off</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fcntl F_GETFL error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    val &amp;= ~flags; <span class="hljs-comment">// turn flags off</span><br><br>    <span class="hljs-keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fcntl F_SETFL error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-ioctl函数"><a href="#13-ioctl函数" class="headerlink" title="13. ioctl函数"></a>13. <code>ioctl</code>函数</h2><h3 id="13-1-功能"><a href="#13-1-功能" class="headerlink" title="13.1 功能"></a>13.1 功能</h3><p>提供一系列I&#x2F;O操作</p><h3 id="13-2-函数原型"><a href="#13-2-函数原型" class="headerlink" title="13.2 函数原型"></a>13.2 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>    <span class="hljs-comment">/* System V */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span> <span class="hljs-comment">/* BSD and Linux */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stropts.h&gt;</span>   <span class="hljs-comment">/* XSI STREAMS */</span></span><br><br><span class="hljs-comment">// 出错返回-1，成功返回其他值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> request, ...)</span>;<br></code></pre></td></tr></table></figure><h3 id="13-3-头文件"><a href="#13-3-头文件" class="headerlink" title="13.3 头文件"></a>13.3 头文件</h3><p>不同设备可能需要自己的专用头文件，如终端I&#x2F;O的<code>ioctl</code>命令都需要头文件<code>&lt;termios.h&gt;</code></p><h2 id="14-dev-fd"><a href="#14-dev-fd" class="headerlink" title="14. /dev/fd"></a>14. <code>/dev/fd</code></h2><p>打开文件<code>/dev/fd/n</code>等效于复制描述符<code>n</code>（假定文件描述符<code>n</code>是打开的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">fd = open(<span class="hljs-string">&quot;/dev/fd/0&quot;</span>, mode);<br></code></pre></td></tr></table></figure><p>某些系统还提供路径名<code>/dev/stdin</code>、<code>/dev/stdout</code> 和<code>/dev/stderr</code></p>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>APUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keyword in C - restrict</title>
    <link href="/2023/09/20/keyword-restrict/"/>
    <url>/2023/09/20/keyword-restrict/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言关键字—restrict"><a href="#C语言关键字—restrict" class="headerlink" title="C语言关键字—restrict"></a>C语言关键字—<code>restrict</code></h1><h2 id="1-编译标准"><a href="#1-编译标准" class="headerlink" title="1. 编译标准"></a>1. 编译标准</h2><p><code>restrict</code>关键字<strong>自C99引入</strong>，编译时可能需要加上编译标准参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -std=c99 ...<br></code></pre></td></tr></table></figure><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p><code>restrict</code>广泛用于函数参数上，用于告知编译器该指针是唯一引用某内存的方式，以进行更有效的优化</p><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 1.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span><br>&#123;<br>    *a = <span class="hljs-number">5</span>;<br>    *b = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">return</span> *a + *b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 2.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rfoo</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-keyword">restrict</span> a, <span class="hljs-type">int</span> *<span class="hljs-keyword">restrict</span> b)</span><br>&#123;<br>    *a = <span class="hljs-number">5</span>;<br>    *b = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">return</span> *a + *b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -std=c99 -O3 -c 1.c 2.c<br>$ objdump -S 1.o 2.o<br><br>1.o:     file format elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;foo&gt;:<br>   0:   c7 07 05 00 00 00       movl   <span class="hljs-variable">$0x5</span>,(%rdi)<br>   6:   c7 06 06 00 00 00       movl   <span class="hljs-variable">$0x6</span>,(%rsi)<br>   c:   8b 07                   mov    (%rdi),%eax<br>   e:   83 c0 06                add    <span class="hljs-variable">$0x6</span>,%eax<br>  11:   c3                      retq<br><br>2.o:     file format elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;rfoo&gt;:<br>   0:   c7 07 05 00 00 00       movl   <span class="hljs-variable">$0x5</span>,(%rdi)<br>   6:   c7 06 06 00 00 00       movl   <span class="hljs-variable">$0x6</span>,(%rsi)<br>   c:   b8 0b 00 00 00          mov    <span class="hljs-variable">$0xb</span>,%eax<br>  11:   c3                      retq<br></code></pre></td></tr></table></figure><h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><p>虽然<strong>C++标准中没有<code>restrict</code>关键字</strong>，但是许多C++编译器支持类似的功能。例如，GCC和Clang支持<code>__restrict__</code>关键字，而Microsoft的Visual C++编译器支持<code>__restrict</code>关键字，这些关键字的语义与C语言中的<code>restrict</code>相似</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Keyword</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Chapter 11 - Associative Containers</title>
    <link href="/2023/09/03/cpp-primer-ch11/"/>
    <url>/2023/09/03/cpp-primer-ch11/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer—Chapter-11-关联式容器"><a href="#C-Primer—Chapter-11-关联式容器" class="headerlink" title="C++ Primer—Chapter 11 关联式容器"></a>C++ Primer—Chapter 11 关联式容器</h1><h2 id="1-辅助类pair"><a href="#1-辅助类pair" class="headerlink" title="1. 辅助类pair"></a>1. 辅助类<code>pair</code></h2><h3 id="1-1-头文件"><a href="#1-1-头文件" class="headerlink" title="1.1 头文件"></a>1.1 头文件</h3><p><code>&lt;utility&gt;</code></p><h3 id="1-2-类模板声明"><a href="#1-2-类模板声明" class="headerlink" title="1.2 类模板声明"></a>1.2 类模板声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-成员类型"><a href="#1-3-成员类型" class="headerlink" title="1.3 成员类型"></a>1.3 成员类型</h3><table><thead><tr><th align="center">成员类型</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center"><code>first_type</code></td><td align="center"><code>T1</code></td></tr><tr><td align="center"><code>second_type</code></td><td align="center"><code>T2</code></td></tr></tbody></table><h3 id="1-4-成员对象"><a href="#1-4-成员对象" class="headerlink" title="1.4 成员对象"></a>1.4 成员对象</h3><table><thead><tr><th align="center">成员名</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center"><code>first</code></td><td align="center"><code>T1</code></td></tr><tr><td align="center"><code>second</code></td><td align="center"><code>T2</code></td></tr></tbody></table><h3 id="1-5-成员函数"><a href="#1-5-成员函数" class="headerlink" title="1.5 成员函数"></a>1.5 成员函数</h3><h4 id="1-5-1-构造函数"><a href="#1-5-1-构造函数" class="headerlink" title="1.5.1 构造函数"></a>1.5.1 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">pair</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> T1 &amp;x, <span class="hljs-type">const</span> T2 &amp;y);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br><span class="hljs-built_in">pair</span>(U1 &amp;&amp;x, U2 &amp;&amp;y);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br><span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> pair&lt;U1, U2&gt; &amp;p);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br><span class="hljs-built_in">pair</span>(pair&lt;U1, U2&gt; &amp;&amp;p);<br><br><span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> pair &amp;p) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// copy constructor</span><br><br><span class="hljs-built_in">pair</span>(pair &amp;&amp;p) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// move constructor</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p1; <span class="hljs-comment">// 0 0</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.9</span>)</span></span>;<br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">// 1 1</span><br></code></pre></td></tr></table></figure><h4 id="1-5-2-operator-：赋值内容"><a href="#1-5-2-operator-：赋值内容" class="headerlink" title="1.5.2 operator=：赋值内容"></a>1.5.2 <code>operator=</code>：赋值内容</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">pair &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> pair &amp;other);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br>pair &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> pair&lt;U1, U2&gt; &amp;other);<br><br>pair &amp;<span class="hljs-keyword">operator</span>=(pair &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br>pair &amp;<span class="hljs-keyword">operator</span>=(pair&lt;U1, U2&gt; &amp;&amp;other);<br></code></pre></td></tr></table></figure><h4 id="1-5-3-swap：交换内容"><a href="#1-5-3-swap：交换内容" class="headerlink" title="1.5.3 swap：交换内容"></a>1.5.3 <code>swap</code>：交换内容</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(pair &amp;other)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h3 id="1-6-非成员函数"><a href="#1-6-非成员函数" class="headerlink" title="1.6 非成员函数"></a>1.6 非成员函数</h3><h4 id="1-6-1-make-pair：创建一个-pair-对象，其类型根据各实参类型定义"><a href="#1-6-1-make-pair：创建一个-pair-对象，其类型根据各实参类型定义" class="headerlink" title="1.6.1 make_pair：创建一个 pair 对象，其类型根据各实参类型定义"></a>1.6.1 <code>make_pair</code>：创建一个 <code>pair</code> 对象，其类型根据各实参类型定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function">std::pair&lt;T1, T2&gt; <span class="hljs-title">make_pair</span><span class="hljs-params">(T1 &amp;&amp;t, T2 &amp;&amp;u)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; std::endl; <span class="hljs-comment">// 0 1</span><br></code></pre></td></tr></table></figure><h4 id="1-6-2-std-swap：特化std-swap算法"><a href="#1-6-2-std-swap：特化std-swap算法" class="headerlink" title="1.6.2 std::swap：特化std::swap算法"></a>1.6.2 <code>std::swap</code>：特化<code>std::swap</code>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(std::pair&lt;T1, T2&gt; &amp;x, std::pair&lt;T1, T2&gt; &amp;y)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(x.swap(y)))</span></span>;<br></code></pre></td></tr></table></figure><h4 id="1-6-3-std-get：访问pair的元素"><a href="#1-6-3-std-get：访问pair的元素" class="headerlink" title="1.6.3 std::get：访问pair的元素"></a>1.6.3 <code>std::get</code>：访问<code>pair</code>的元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> I, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">typename</span> std::tuple_element&lt;I, std::pair&lt;T1, T2&gt;&gt;::<span class="hljs-function">type &amp;</span><br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// I为0或1</span><br><br><span class="hljs-comment">// 获取T.first的引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T &amp;<span class="hljs-title">get</span><span class="hljs-params">(std::pair&lt;T, U&gt; &amp;p)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// T和U必须为不同类型</span><br><br><span class="hljs-comment">// 获取T.second的引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T &amp;<span class="hljs-title">get</span><span class="hljs-params">(std::pair&lt;U, T&gt; &amp;p)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// T和U必须为不同类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1.2f</span>);<br>std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(p) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">float</span>&gt;(p) &lt;&lt; std::endl; <span class="hljs-comment">// 0 1.2</span><br></code></pre></td></tr></table></figure><h2 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2. 关联容器"></a>2. 关联容器</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul><li><p>有序关联容器</p><ul><li><code>map</code></li><li><code>set</code> </li><li><code>multimap</code></li><li><code>multiset</code></li></ul></li><li><p>无序关联容器</p><ul><li><code>unordered_map</code></li><li><code>unordered_set</code></li><li><code>unordered_multimap</code></li><li><code>unordered_multiset</code></li></ul></li></ul><table><thead><tr><th align="center">容器</th><th align="center">头文件</th><th align="center">实现</th><th align="center">元素</th><th align="center">键是否唯一</th></tr></thead><tbody><tr><td align="center"><code>map</code></td><td align="center"><code>map</code></td><td align="center">红黑树</td><td align="center">键值对</td><td align="center">&#10004;</td></tr><tr><td align="center"><code>set</code></td><td align="center"><code>set</code></td><td align="center">红黑树</td><td align="center">键</td><td align="center">&#10004;</td></tr><tr><td align="center"><code>multimap</code></td><td align="center"><code>map</code></td><td align="center">红黑树</td><td align="center">键值对</td><td align="center">&#10006;</td></tr><tr><td align="center"><code>multiset</code></td><td align="center"><code>set</code></td><td align="center">红黑树</td><td align="center">键</td><td align="center">&#10006;</td></tr><tr><td align="center"><code>unordered_map</code></td><td align="center"><code>unordered_map</code></td><td align="center">哈希表</td><td align="center">键值对</td><td align="center">&#10004;</td></tr><tr><td align="center"><code>unordered_set</code></td><td align="center"><code>unordered_set</code></td><td align="center">哈希表</td><td align="center">键</td><td align="center">&#10004;</td></tr><tr><td align="center"><code>unordered_multimap</code></td><td align="center"><code>unordered_map</code></td><td align="center">哈希表</td><td align="center">键值对</td><td align="center">&#10006;</td></tr><tr><td align="center"><code>unordered_multiset</code></td><td align="center"><code>unordered_set</code></td><td align="center">哈希表</td><td align="center">键</td><td align="center">&#10006;</td></tr></tbody></table><h3 id="2-2-成员类型"><a href="#2-2-成员类型" class="headerlink" title="2.2 成员类型"></a>2.2 成员类型</h3><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td><code>key_type</code></td><td><code>Key</code></td></tr><tr><td><code>mapped_type</code></td><td><code>T</code></td></tr><tr><td><code>value_type</code></td><td><code>std::pair&lt;const Key, T&gt;</code></td></tr><tr><td><code>iterator</code></td><td>指向<code>value_type</code>的老式双向迭代器</td></tr></tbody></table><h3 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map"></a>2.3 <code>map</code></h3><h4 id="2-3-1-类模板声明"><a href="#2-3-1-类模板声明" class="headerlink" title="2.3.1 类模板声明"></a>2.3.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = std::less&lt;Key&gt;,<br>          <span class="hljs-keyword">class</span> Allocator = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;<br><span class="hljs-keyword">class</span> map;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-构造函数"><a href="#2-3-2-构造函数" class="headerlink" title="2.3.2 构造函数"></a>2.3.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>();<br><br><span class="hljs-comment">// [first, last)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-built_in">map</span>(InputIt first, InputIt last, <span class="hljs-type">const</span> Compare &amp;comp = <span class="hljs-built_in">Compare</span>(), <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-built_in">map</span>(<span class="hljs-type">const</span> map &amp;other);<br><span class="hljs-built_in">map</span>(map &amp;&amp;other);<br><br><span class="hljs-built_in">map</span>(std::initializer_list&lt;value_type&gt; init, <span class="hljs-type">const</span> Compare &amp;comp = <span class="hljs-built_in">Compare</span>(), <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; m1;<br>std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; m2&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">98</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">99</span>&#125;&#125;;<br><br><span class="hljs-keyword">auto</span> it = m2.<span class="hljs-built_in">cbegin</span>();<br>++it;<br><span class="hljs-function">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">m3</span><span class="hljs-params">(m2.cbegin(), it)</span></span>; <span class="hljs-comment">// m3:&#123;&#123;&#x27;a&#x27;, 97&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-3-元素访问"><a href="#2-3-3-元素访问" class="headerlink" title="2.3.3 元素访问"></a>2.3.3 元素访问</h4><ul><li><code>at</code>：访问指定的元素，同时进行越界检查</li><li><code>operator[]</code>：访问<strong>或插入</strong>指定的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; ascii&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">98</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">99</span>&#125;&#125;;<br>std::cout &lt;&lt; ascii.<span class="hljs-built_in">at</span>(<span class="hljs-string">&#x27;c&#x27;</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 99</span><br>std::cout &lt;&lt; ascii[<span class="hljs-string">&#x27;a&#x27;</span>] &lt;&lt; std::endl;    <span class="hljs-comment">// 97</span><br>std::cout &lt;&lt; ascii[<span class="hljs-string">&#x27;d&#x27;</span>] &lt;&lt; std::endl;    <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h4 id="2-3-4-迭代器"><a href="#2-3-4-迭代器" class="headerlink" title="2.3.4  迭代器"></a>2.3.4  迭代器</h4><ul><li><code>begin</code> <code>cbegin</code>：返回指向起始的迭代器</li><li><code>end</code> <code>cend</code>：返回指向末尾的迭代器</li><li><code>rbegin</code> <code>crbegin</code>：返回指向起始的逆向迭代器</li><li><code>rend</code> <code>crend</code>：返回指向末尾的逆向迭代器</li></ul><h4 id="2-3-5-容量"><a href="#2-3-5-容量" class="headerlink" title="2.3.5 容量"></a>2.3.5 容量</h4><ul><li><p><code>empty</code>：检查容器是否为空</p></li><li><p><code>size</code>：返回容纳的元素数</p></li><li><p><code>max_size</code>：返回可容纳的最大元素数</p></li></ul><h4 id="2-3-6-修改"><a href="#2-3-6-修改" class="headerlink" title="2.3.6 修改"></a>2.3.6 修改</h4><ul><li><code>clear</code>：清除内容</li><li><code>insert</code>：插入元素或结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type &amp;value)</span></span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(P &amp;&amp;value)</span></span>; <span class="hljs-comment">// C++11</span><br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(value_type &amp;&amp;value)</span></span>; <span class="hljs-comment">// C++17</span><br><br><span class="hljs-comment">// 插入value到尽可能接近正好在pos之前的位置</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, <span class="hljs-type">const</span> value_type &amp;value)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, P &amp;&amp;value)</span></span>; <span class="hljs-comment">// C++11</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, value_type &amp;&amp;value)</span></span>; <span class="hljs-comment">// C++17</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(InputIt first, InputIt last)</span></span>; <span class="hljs-comment">// [first, last)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::initializer_list&lt;value_type&gt; ilist)</span></span>; <span class="hljs-comment">// C++11</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; ascii&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">98</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">99</span>&#125;&#125;;<br>ascii.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">100</span>&#125;);<br>ascii.<span class="hljs-built_in">insert</span>(ascii.<span class="hljs-built_in">cbegin</span>(), &#123;<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">101</span>&#125;);<br>ascii.<span class="hljs-built_in">insert</span>(&#123;&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">102</span>&#125;, &#123;<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">103</span>&#125;&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>insert_or_assign</code>*(C++17)*：插入元素，或若键已存在则赋值给当前元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert_or_assign</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type &amp;k, M &amp;&amp;obj)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert_or_assign</span><span class="hljs-params">(key_type &amp;&amp;k, M &amp;&amp;obj)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">insert_or_assign</span><span class="hljs-params">(const_iterator hint, <span class="hljs-type">const</span> key_type &amp;k, M &amp;&amp;obj)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">insert_or_assign</span><span class="hljs-params">(const_iterator hint, key_type &amp;&amp;k, M &amp;&amp;obj)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; ascii&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">96</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">98</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">99</span>&#125;&#125;;<br>ascii.<span class="hljs-built_in">insert_or_assign</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">97</span>);  <span class="hljs-comment">// ascii:&#123;&#123;&#x27;a&#x27;, 97&#125;, &#123;&#x27;b&#x27;, 98&#125;, &#123;&#x27;c&#x27;, 99&#125;&#125;</span><br>ascii.<span class="hljs-built_in">insert_or_assign</span>(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// ascii:&#123;&#123;&#x27;a&#x27;, 97&#125;, &#123;&#x27;b&#x27;, 98&#125;, &#123;&#x27;c&#x27;, 99&#125;, &#123;&#x27;d&#x27;, 100&#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>emplace</code>*(C++11)*：原位构造元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">emplace</span><span class="hljs-params">(Args &amp;&amp;...args)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; ascii&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">98</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">99</span>&#125;&#125;;<br>ascii.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// ascii:&#123;&#123;&#x27;a&#x27;, 97&#125;, &#123;&#x27;b&#x27;, 98&#125;, &#123;&#x27;c&#x27;, 99&#125;, &#123;&#x27;d&#x27;, 100&#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>emplace_hint</code>*(C++11)*：使用提示原位构造元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">iterator <span class="hljs-title">emplace_hint</span><span class="hljs-params">(const_iterator hint, Args &amp;&amp;...args)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>try_emplace</code>*(C++17)*：若键不存在则原位构造元素并插入，若键存在则不做任何事</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">try_emplace</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type &amp;k, Args &amp;&amp;...args)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">try_emplace</span><span class="hljs-params">(key_type &amp;&amp;k, Args &amp;&amp;...args)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">iterator <span class="hljs-title">try_emplace</span><span class="hljs-params">(const_iterator hint, <span class="hljs-type">const</span> key_type &amp;k, Args &amp;&amp;...args)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">iterator <span class="hljs-title">try_emplace</span><span class="hljs-params">(const_iterator hint, key_type &amp;&amp;k, Args &amp;&amp;...args)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>erase</code>：擦除元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator pos)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator pos)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator first, const_iterator last)</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">(K &amp;&amp;x)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>swap</code>：交换内容</li><li><code>extract</code>*(C++17)*：从另一容器释出结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">node_type <span class="hljs-title">extract</span><span class="hljs-params">(const_iterator position)</span></span>;<br><span class="hljs-function">node_type <span class="hljs-title">extract</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type &amp;k)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">node_type <span class="hljs-title">extract</span><span class="hljs-params">(K &amp;&amp;x)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>merge</code>*(C++17)*：从另一容器接合结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::map&lt;Key, T, C2, Allocator&gt; &amp;source)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::map&lt;Key, T, C2, Allocator&gt; &amp;&amp;source)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::multimap&lt;Key, T, C2, Allocator&gt; &amp;source)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::multimap&lt;Key, T, C2, Allocator&gt; &amp;&amp;source)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-7-查找"><a href="#2-3-7-查找" class="headerlink" title="2.3.7 查找"></a>2.3.7 查找</h4><ul><li><code>count</code>：返回匹配特定键的元素数量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">size_type <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>find</code>：寻找带有特定键的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br><span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span></span>; <span class="hljs-comment">// C++14</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C++14</span><br></code></pre></td></tr></table></figure><ul><li><code>contains</code>*(C++20)*：检查容器是否含有带特定键的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>equal_range</code>：返回匹配特定键的元素范围</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::pair&lt;iterator, iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br><span class="hljs-function">std::pair&lt;const_iterator, const_iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">std::pair&lt;iterator, iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span></span>; <span class="hljs-comment">// C++14</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">std::pair&lt;const_iterator, const_iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C++14</span><br></code></pre></td></tr></table></figure><ul><li><code>lower_bound</code>：返回指向首个不小于给定键的元素的迭代器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br><span class="hljs-function">const_iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span></span>; <span class="hljs-comment">// C++14</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">const_iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C++14</span><br></code></pre></td></tr></table></figure><ul><li><code>upper_bound</code>：返回指向首个大于给定键的元素的迭代器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br><span class="hljs-function">const_iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span></span>; <span class="hljs-comment">// C++14</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-function">const_iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C++14</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a>2.4 <code>set</code></h3><p>大致同<code>map</code>，区别如下：</p><ul><li>不可以用<code>at</code>和<code>operator[]</code>进行元素访问</li><li>在修改容器方面，同<code>map</code>相比，没有<code>insert_or_assign</code>和<code>try_emplace</code>函数</li></ul><hr><h3 id="2-5-multimap"><a href="#2-5-multimap" class="headerlink" title="2.5  multimap"></a>2.5  <code>multimap</code></h3><p>大致同<code>map</code>，区别是不可以用<code>at</code>和<code>operator[]</code>进行元素访问</p><hr><h3 id="2-6-multiset"><a href="#2-6-multiset" class="headerlink" title="2.6 multiset"></a>2.6 <code>multiset</code></h3><p>大致同<code>set</code></p><hr><h3 id="2-7-unordered-map"><a href="#2-7-unordered-map" class="headerlink" title="2.7 unordered_map"></a>2.7 <code>unordered_map</code></h3><h4 id="2-7-1-类模板声明"><a href="#2-7-1-类模板声明" class="headerlink" title="2.7.1 类模板声明"></a>2.7.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> KeyEqual = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Allocator = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;<br><span class="hljs-keyword">class</span> unordered_map;<br></code></pre></td></tr></table></figure><h4 id="2-7-2-构造函数"><a href="#2-7-2-构造函数" class="headerlink" title="2.7.2 构造函数"></a>2.7.2 构造函数</h4><h4 id="2-7-3-迭代器"><a href="#2-7-3-迭代器" class="headerlink" title="2.7.3 迭代器"></a>2.7.3 迭代器</h4><ul><li><code>begin</code> <code>cbegin</code></li><li><code>end</code> <code>cend</code></li></ul><h4 id="2-7-4-修改"><a href="#2-7-4-修改" class="headerlink" title="2.7.4 修改"></a>2.7.4 修改</h4><p>同<code>map</code></p><h4 id="2-7-5-查找"><a href="#2-7-5-查找" class="headerlink" title="2.7.5 查找"></a>2.7.5 查找</h4><ul><li><code>at</code></li><li><code>operator[]</code></li><li><code>count</code></li><li><code>find</code></li><li><code>contains</code></li><li><code>equal_range</code></li></ul><h4 id="2-7-6-桶接口"><a href="#2-7-6-桶接口" class="headerlink" title="2.7.6 桶接口"></a>2.7.6 桶接口</h4><ul><li><code>begin(size_type)</code> <code>cbegin(size_type)</code>：返回一个迭代器，指向指定的桶的开始</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">local_iterator <span class="hljs-title">begin</span><span class="hljs-params">(size_type n)</span></span>;<br><span class="hljs-function">const_local_iterator <span class="hljs-title">begin</span><span class="hljs-params">(size_type n)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">const_local_iterator <span class="hljs-title">cbegin</span><span class="hljs-params">(size_type n)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>end(size_type)</code> <code>cend(size_type)</code>：返回一个迭代器，指向指定的桶的末尾</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">local_iterator <span class="hljs-title">end</span><span class="hljs-params">(size_type n)</span></span>;<br><span class="hljs-function">const_local_iterator <span class="hljs-title">end</span><span class="hljs-params">(size_type n)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">const_local_iterator <span class="hljs-title">cend</span><span class="hljs-params">(size_type n)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>bucket_count</code>：返回桶数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">bucket_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>max_bucket_count</code>：返回桶的最大数量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">max_bucket_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>bucket_size</code>：返回在特定的桶中的元素数量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">bucket_size</span><span class="hljs-params">(size_type n)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>bucket</code>：返回带有特定键的桶</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">bucket</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-7-7-哈希策略"><a href="#2-7-7-哈希策略" class="headerlink" title="2.7.7 哈希策略"></a>2.7.7 哈希策略</h4><ul><li><code>load_factor</code>：返回每个桶的平均元素数量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">load_factor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>max_load_factor</code>：管理每个桶的平均元素数量的最大值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">max_load_factor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 返回最大加载因子</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_load_factor</span><span class="hljs-params">(<span class="hljs-type">float</span> ml)</span></span>; <span class="hljs-comment">//  设置最大加载因子为ml</span><br></code></pre></td></tr></table></figure><ul><li><code>rehash</code>：为至少为指定数量的桶预留存储空间并重新生成散列表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">(size_type count)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>reserve</code>：为至少为指定数量的元素预留存储空间并重新生成哈希表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(size_type count)</span></span>; <span class="hljs-comment">// 设置桶数为适应至少count个元素，而不超出最大加载因子所需的数，并重哈希容器</span><br></code></pre></td></tr></table></figure><h3 id="2-8-unordered-set"><a href="#2-8-unordered-set" class="headerlink" title="2.8 unordered_set"></a>2.8 <code>unordered_set</code></h3><p>大致同<code>unordered_map</code>，区别如下：</p><ul><li>不可以用<code>at</code>和<code>operator[]</code>进行元素访问</li><li>在修改容器方面，同<code>unordered_map</code>相比，没有<code>insert_or_assign</code>和<code>try_emplace</code>函数</li></ul><h3 id="2-9-unordered-multimap"><a href="#2-9-unordered-multimap" class="headerlink" title="2.9 unordered_multimap"></a>2.9 <code>unordered_multimap</code></h3><p>大致同<code>unordered_map</code>，区别是不可使用<code>at</code>和<code>operator[]</code>进行查找</p><h3 id="2-10-unordered-multiset"><a href="#2-10-unordered-multiset" class="headerlink" title="2.10 unordered_multiset"></a>2.10 <code>unordered_multiset</code></h3><p>大致同<code>unordered_set</code></p>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Chapter 09 - Sequential Containers</title>
    <link href="/2023/09/03/cpp-primer-ch09/"/>
    <url>/2023/09/03/cpp-primer-ch09/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer—Chapter-09-序列式容器"><a href="#C-Primer—Chapter-09-序列式容器" class="headerlink" title="C++ Primer—Chapter 09 序列式容器"></a>C++ Primer—Chapter 09 序列式容器</h1><h2 id="1-STL六大组件"><a href="#1-STL六大组件" class="headerlink" title="1. STL六大组件"></a>1. STL六大组件</h2><h3 id="1-1-分配器：空间配置与管理"><a href="#1-1-分配器：空间配置与管理" class="headerlink" title="1.1 分配器：空间配置与管理"></a>1.1 分配器：空间配置与管理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">allocator</span>;<br><br><span class="hljs-comment">// 分配器使用之处</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector;<br></code></pre></td></tr></table></figure><h3 id="1-2-迭代器：-统一的访问容器元素的方式，泛型指针"><a href="#1-2-迭代器：-统一的访问容器元素的方式，泛型指针" class="headerlink" title="1.2 迭代器： 统一的访问容器元素的方式，泛型指针"></a>1.2 迭代器： 统一的访问容器元素的方式，泛型指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 可能的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-keyword">typedef</span> T value_type;<br>    <span class="hljs-keyword">typedef</span> value_type *iterator;<br>    ....<br><span class="hljs-keyword">private</span>:<br>    iterator start;<br>    iterator finish;<br>    ...<br>        <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> start;&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-3-容器：存储和管理数据"><a href="#1-3-容器：存储和管理数据" class="headerlink" title="1.3 容器：存储和管理数据"></a>1.3 容器：存储和管理数据</h3><ul><li><p>顺序容器</p><ul><li><code>array</code>*</li><li><code>deque</code></li><li><code>forward_list</code>*</li><li><code>list</code></li><li><code>string</code></li><li><code>vector</code></li></ul></li><li><p>关联容器</p><ul><li><code>map</code></li><li><code>multimap</code></li><li><code>set</code></li><li><code>multiset</code></li><li><code>unordered_map</code>*</li><li><code>unordered_set</code>*</li><li><code>unordered_multimap</code>*</li><li><code>unordered_multiset</code>*</li></ul></li></ul><p><em>注：带*为自C++11起</em></p><h3 id="1-4-算法：对容器中的数据进行各种操作和处理，如copy、count、find等"><a href="#1-4-算法：对容器中的数据进行各种操作和处理，如copy、count、find等" class="headerlink" title="1.4 算法：对容器中的数据进行各种操作和处理，如copy、count、find等"></a>1.4 算法：对容器中的数据进行各种操作和处理，如<code>copy</code>、<code>count</code>、<code>find</code>等</h3><h3 id="1-5-仿函数（函数对象）：行为类似函数，可作为算法的某种策略，需重载operator"><a href="#1-5-仿函数（函数对象）：行为类似函数，可作为算法的某种策略，需重载operator" class="headerlink" title="1.5 仿函数（函数对象）：行为类似函数，可作为算法的某种策略，需重载operator()"></a>1.5 仿函数（函数对象）：行为类似函数，可作为算法的某种策略，需重载<code>operator()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">greater</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;lhs, <span class="hljs-type">const</span> T &amp;rhs)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; ivec&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>&#125;;<br><br><span class="hljs-comment">// 降序排序</span><br>std::<span class="hljs-built_in">sort</span>(ivec.<span class="hljs-built_in">begin</span>(), ivec.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h3 id="1-6-适配器：修饰容器、仿函数和迭代器接口"><a href="#1-6-适配器：修饰容器、仿函数和迭代器接口" class="headerlink" title="1.6 适配器：修饰容器、仿函数和迭代器接口"></a>1.6 适配器：修饰容器、仿函数和迭代器接口</h3><h4 id="1-6-1-容器适配器"><a href="#1-6-1-容器适配器" class="headerlink" title="1.6.1 容器适配器"></a>1.6.1 容器适配器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::deque&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> stack;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::deque&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> queue;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>          <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;&gt;<br><span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">适配器</th><th align="center">所需头文件</th><th align="center">底层容器</th><th align="center">元素访问</th><th align="center">容量</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center"><code>stack</code></td><td align="center"><code>&lt;stack&gt;</code></td><td align="center"><code>deque</code>（默认）<br><code>vector</code><br><code>list</code></td><td align="center"><code>top</code></td><td align="center"><code>empty</code> <br><code>size</code></td><td align="center"><code>push</code><br><code>emplace</code>*<br><code>pop</code><br><code>swap</code>*</td></tr><tr><td align="center"><code>queue</code></td><td align="center"><code>&lt;queue&gt;</code></td><td align="center"><code>deque</code>（默认）<br><code>list</code></td><td align="center"><code>front</code><br><code>back</code></td><td align="center"><code>empty</code><br><code>size</code></td><td align="center"><code>push</code><br><code>emplace</code>*<br><code>pop</code><br><code>swap</code>*</td></tr><tr><td align="center"><code>priority_queue</code></td><td align="center"><code>&lt;queue&gt;</code></td><td align="center"><code>vector</code>（默认）<br><code>deque</code></td><td align="center"><code>top</code></td><td align="center"><code>empty</code><br><code>size</code></td><td align="center"><code>push</code><br><code>emplace</code>*<br><code>pop</code><br><code>swap</code>*</td></tr></tbody></table><p><em>注：带*为自C++11起</em></p><table><thead><tr><th align="center">成员类型</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center"><code>container_type</code></td><td align="center"><code>Container</code></td></tr><tr><td align="center"><code>value_compare</code>（仅<code>priority_queue</code>）</td><td align="center">Compare（仅<code>priority_queue</code>）</td></tr><tr><td align="center"><code>value_type</code></td><td align="center"><code>Container::value_type</code></td></tr><tr><td align="center"><code>size_type</code></td><td align="center"><code>Container::size_type</code></td></tr><tr><td align="center"><code>reference</code></td><td align="center"><code>Container::reference</code></td></tr><tr><td align="center"><code>const_reference</code></td><td align="center"><code>Container::const_reference</code></td></tr></tbody></table><h4 id="1-6-2-仿函数适配器"><a href="#1-6-2-仿函数适配器" class="headerlink" title="1.6.2 仿函数适配器"></a>1.6.2 仿函数适配器</h4><h4 id="1-6-3-迭代器适配器"><a href="#1-6-3-迭代器适配器" class="headerlink" title="1.6.3 迭代器适配器"></a>1.6.3 迭代器适配器</h4><h2 id="2-顺序容器"><a href="#2-顺序容器" class="headerlink" title="2. 顺序容器"></a>2. 顺序容器</h2><h3 id="2-1-顺序容器概览"><a href="#2-1-顺序容器概览" class="headerlink" title="2.1 顺序容器概览"></a>2.1 顺序容器概览</h3><p><del>所有顺序容器都提供了<strong>顺序</strong>访问元素的能力</del>，所需头文件与容器同名</p><table><thead><tr><th align="center">顺序容器</th><th align="center">大小能否动态变化</th><th align="center">能否随机访问元素</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center"><code>array</code></td><td align="center">&#10006;</td><td align="center">&#10004;</td><td align="center">语义上等同于C风格数组，不能添加&#x2F;删除元素</td></tr><tr><td align="center"><code>deque</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">双端队列，头尾插入&#x2F;删除很快</td></tr><tr><td align="center"><code>forward_list</code></td><td align="center">&#10004;</td><td align="center">&#10006;</td><td align="center">单向链表，任意位置插入&#x2F;删除很快</td></tr><tr><td align="center"><code>list</code></td><td align="center">&#10004;</td><td align="center">&#10006;</td><td align="center">双向链表，任意位置插入&#x2F;删除很快</td></tr><tr><td align="center"><code>string</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">类似<code>vector</code>，专门用于保存字符，尾部插入&#x2F;删除很快</td></tr><tr><td align="center"><code>vector</code></td><td align="center">&#10004;</td><td align="center">&#10004;</td><td align="center">可变大小数组，尾部插入&#x2F;删除很快</td></tr></tbody></table><h3 id="2-2-类型别名"><a href="#2-2-类型别名" class="headerlink" title="2.2 类型别名"></a>2.2 类型别名</h3><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td><code>value_type</code></td><td><code>T</code></td></tr><tr><td><code>size_type</code></td><td>无符号整数类型（通常是 <code>std::size_t</code>）</td></tr><tr><td><code>difference_type</code></td><td>有符号整数类型（通常是 <code>std::ptrdiff_t</code>）</td></tr><tr><td><code>reference</code></td><td><code>value_type&amp;</code></td></tr><tr><td><code>const_reference</code></td><td><code>const value_type&amp;</code></td></tr><tr><td><code>pointer</code></td><td><code>std::allocator_traits&lt;Allocator&gt;::pointer</code></td></tr><tr><td><code>const_pointer</code></td><td><code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code></td></tr><tr><td><code>iterator</code></td><td>LegacyRandomAccessIterator to <code>value_type</code></td></tr><tr><td><code>const_iterator</code></td><td>LegacyRandomAccessIterator to <code>const value_type</code></td></tr><tr><td><code>reverse_iterator</code></td><td><code>std::reverse_iterator&lt;iterator&gt;</code></td></tr><tr><td><code>const_reverse_iterator</code></td><td><code>std::reverse_iterator&lt;const_iterator&gt;</code></td></tr></tbody></table><hr><h3 id="2-3-array"><a href="#2-3-array" class="headerlink" title="2.3 array"></a>2.3 <code>array</code></h3><h4 id="2-3-1-类模板声明"><a href="#2-3-1-类模板声明" class="headerlink" title="2.3.1 类模板声明"></a>2.3.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array</span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-构造函数"><a href="#2-3-2-构造函数" class="headerlink" title="2.3.2 构造函数"></a>2.3.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 聚合初始化</span><br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr1 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;;<br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr2&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// C++11</span><br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr3 = &#123;<span class="hljs-number">3</span>&#125;;    <span class="hljs-comment">// 3 0 0</span><br><span class="hljs-function">std::array&lt;<span class="hljs-type">int</span>, 3&gt; <span class="hljs-title">arr4</span><span class="hljs-params">(arr1)</span></span>;    <span class="hljs-comment">// 3 6 9</span><br></code></pre></td></tr></table></figure><h4 id="2-3-3-元素访问"><a href="#2-3-3-元素访问" class="headerlink" title="2.3.3 元素访问"></a>2.3.3 元素访问</h4><ul><li><p><code>at</code>：访问指定的元素，同时进行越界检查</p></li><li><p><code>operator[]</code>：访问指定的元素</p></li><li><p><code>front</code>：访问第一个元素</p></li><li><p><code>back</code>：访问最后一个元素</p></li><li><p><code>data</code>：直接访问底层数组</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 若!(pos &lt; size()) 则抛出std::out_of_range</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> reference <span class="hljs-title">at</span><span class="hljs-params">(size_type pos)</span></span>;<br><span class="hljs-comment">// 不会做边界检查，若越界会导致未定义行为</span><br><span class="hljs-keyword">constexpr</span> reference <span class="hljs-keyword">operator</span>[](size_type pos);<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> reference <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> reference <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 返回指向作为元素存储工作的底层数组的指针</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T *<span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-4-迭代器"><a href="#2-3-4-迭代器" class="headerlink" title="2.3.4 迭代器"></a>2.3.4 迭代器</h4><ul><li><p><code>begin</code> <code>cbegin</code>：返回指向起始的迭代器</p></li><li><p><code>end</code> <code>cend</code>：返回指向末尾的迭代器</p></li><li><p><code>rbegin</code> <code>crbegin</code>：返回指向起始的逆向迭代器</p></li><li><p><code>rend</code> <code>crend</code>：返回指向末尾的逆向迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::array&lt;<span class="hljs-type">int</span>, 4&gt; iarr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> rit = iarr.<span class="hljs-built_in">crbegin</span>(); rit != iarr.<span class="hljs-built_in">crend</span>(); ++rit)<br>    std::cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 4 3 2 1</span><br></code></pre></td></tr></table></figure><h4 id="2-3-5-容量"><a href="#2-3-5-容量" class="headerlink" title="2.3.5 容量"></a>2.3.5 容量</h4><ul><li><code>empty</code>：检查容器是否为空</li><li><code>size</code>：返回容纳的元素数</li><li><code>max_size</code>：返回可容纳的最大元素数。因为每个<code>std::array&lt;T, N&gt;</code>都是固定大小容器，故<code>max_size</code> 返回的值等于 <code>N</code> （亦为<code>size</code>返回的值）</li></ul><h4 id="2-3-6-操作"><a href="#2-3-6-操作" class="headerlink" title="2.3.6 操作"></a>2.3.6 操作</h4><ul><li><code>fill</code>：以指定值填充容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>swap</code>：交换内容。将容器内容与 <code>other</code> 的内容交换。<strong>不会导致迭代器和引用关联到别的容器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(array &amp;other)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::array&lt;<span class="hljs-type">int</span>, 3&gt; a1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, a2&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br><span class="hljs-keyword">auto</span> it1 = a1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it2 = a2.<span class="hljs-built_in">begin</span>();<br><span class="hljs-type">int</span> &amp;ref1 = a1[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> &amp;ref2 = a2[<span class="hljs-number">1</span>];<br><br>a1.<span class="hljs-built_in">swap</span>(a2);<br><br>std::cout &lt;&lt; *it1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *it2 &lt;&lt; std::endl; <span class="hljs-comment">// 4 1</span><br>std::cout &lt;&lt; ref1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ref2 &lt;&lt; std::endl; <span class="hljs-comment">// 5 2</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-4-deque"><a href="#2-4-deque" class="headerlink" title="2.4 deque"></a>2.4 <code>deque</code></h3><h4 id="2-4-1-类模板声明"><a href="#2-4-1-类模板声明" class="headerlink" title="2.4.1 类模板声明"></a>2.4.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> deque;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-构造函数"><a href="#2-4-2-构造函数" class="headerlink" title="2.4.2 构造函数"></a>2.4.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">deque</span>();<br><br><span class="hljs-built_in">deque</span>(size_type count, <span class="hljs-type">const</span> T &amp;value, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">deque</span><span class="hljs-params">(size_type count)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-built_in">deque</span>(InputIt first, InputIt last, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// [first, last)</span><br><br><span class="hljs-built_in">deque</span>(<span class="hljs-type">const</span> deque &amp;other);<br><br><span class="hljs-built_in">deque</span>(deque &amp;&amp;other); <span class="hljs-comment">// C++11</span><br><br><span class="hljs-built_in">eque</span>(std::initializer_list&lt;T&gt; init, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// C++11</span><br></code></pre></td></tr></table></figure><h4 id="2-4-3-元素访问"><a href="#2-4-3-元素访问" class="headerlink" title="2.4.3 元素访问"></a>2.4.3 元素访问</h4><ul><li><code>at</code> </li><li><code>operator[]</code></li><li><code>front</code></li><li><code>back</code></li></ul><h4 id="2-4-4-迭代器"><a href="#2-4-4-迭代器" class="headerlink" title="2.4.4 迭代器"></a>2.4.4 迭代器</h4><ul><li><p><code>begin</code> <code>cbegin</code></p></li><li><p><code>end</code> <code>cend</code></p></li><li><p><code>rbegin</code> <code>crbegin</code></p></li><li><p><code>rend</code> <code>crend</code></p></li></ul><h4 id="2-4-5-容量"><a href="#2-4-5-容量" class="headerlink" title="2.4.5 容量"></a>2.4.5 容量</h4><ul><li><code>empty</code></li><li><code>size</code></li><li><code>max_size</code></li><li><code>shrink_to_fit</code>：通过释放未使用的内存减少内存的使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink_to_fit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-4-6-修改"><a href="#2-4-6-修改" class="headerlink" title="2.4.6 修改"></a>2.4.6 修改</h4><ul><li><code>clear</code>：清除内容</li><li><code>insert</code>：插入元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在pos前插入value</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, <span class="hljs-type">const</span> T &amp;value)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, T &amp;&amp;value)</span></span>;<br><br><span class="hljs-comment">// 在pos前插入value的count个副本</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, size_type count, <span class="hljs-type">const</span> T &amp;value)</span></span>;<br><br><span class="hljs-comment">// 在pos前插入来自范围[first, last)的元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, InputIt first, InputIt last)</span></span>;<br><br><span class="hljs-comment">//  在pos前插入来自initializer_list ilist的元素</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, std::initializer_list&lt;T&gt; ilist)</span></span>;<br></code></pre></td></tr></table></figure></li><li><code>emplace</code>：原位构造元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 直接于pos前插入元素到容器中</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">iterator <span class="hljs-title">emplace</span><span class="hljs-params">(const_iterator pos, Args &amp;&amp;...args)</span></span>;<br></code></pre></td></tr></table></figure></li><li><code>erase</code>：擦除元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// iterator是最后移除元素之后的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator pos)</span></span>;<br><br><span class="hljs-comment">// 移除[first, last)中的元素</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator first, const_iterator last)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::deque&lt;<span class="hljs-type">int</span>&gt; ideq = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">auto</span> it = ideq.<span class="hljs-built_in">erase</span>(ideq.<span class="hljs-built_in">cbegin</span>() + <span class="hljs-number">2</span>);<br><span class="hljs-comment">// ideq: &#123;0, 1, 3, 4, 5&#125;</span><br><span class="hljs-comment">// *it == 2</span><br><br>ideq.<span class="hljs-built_in">erase</span>(ideq.<span class="hljs-built_in">cbegin</span>(), ideq.<span class="hljs-built_in">cbegin</span>() + <span class="hljs-number">3</span>);<br><span class="hljs-comment">// ideq: &#123;4, 5&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>push_back</code>：将元素添加到容器末尾</li><li><code>emplace_back</code>：在容器末尾就地构造元素</li><li><code>pop_back</code>：移除末元素</li><li><code>push_front</code>：插入元素到容器起始</li><li><code>emplace_front</code>：在容器头部原位构造元素</li><li><code>pop_front</code>：移除首元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T &amp;&amp;value)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args &amp;&amp;...args)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(T &amp;&amp;value)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_front</span><span class="hljs-params">(Args &amp;&amp;...args)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>resize</code>：改变容器中可存储元素的个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 重设容器大小以容纳 count 个元素，在count == size()时不做任何事</span><br><span class="hljs-comment">// 如果当前大小大于count，那么减小容器到它的开头count个元素</span><br><span class="hljs-comment">// 如果当前大小小于count，那么后附额外的默认插入元素/value副本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type count, <span class="hljs-type">const</span> value_type &amp;value)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>swap</code>：交换内容</li></ul><h4 id="2-4-7-其他成员函数"><a href="#2-4-7-其他成员函数" class="headerlink" title="2.4.7 其他成员函数"></a>2.4.7 其他成员函数</h4><ul><li><code>assign</code>：将值赋给容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(size_type count, <span class="hljs-type">const</span> T &amp;value)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(InputIt first, InputIt last)</span></span>; <span class="hljs-comment">// [first, last)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(std::initializer_list&lt;T&gt; ilist)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>get_allocator</code>：返回相关的分配器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">allocator_type <span class="hljs-title">get_allocator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><hr><h3 id="2-5-forward-list"><a href="#2-5-forward-list" class="headerlink" title="2.5 forward_list"></a>2.5 <code>forward_list</code></h3><h4 id="2-5-1-类模板声明"><a href="#2-5-1-类模板声明" class="headerlink" title="2.5.1 类模板声明"></a>2.5.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> forward_list;<br></code></pre></td></tr></table></figure><h4 id="2-5-2-构造函数"><a href="#2-5-2-构造函数" class="headerlink" title="2.5.2 构造函数"></a>2.5.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 全部自C++11</span><br>forward_list();<br><br>forward_list(size_type count, <span class="hljs-type">const</span> T &amp;value, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">forward_list</span><span class="hljs-params">(size_type count)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br>forward_list(InputIt first, InputIt last, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br>forward_list(<span class="hljs-type">const</span> forward_list &amp;other);<br><br>forward_list(forward_list &amp;&amp;other); <br><br>forward_list(std::initializer_list&lt;T&gt; init, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br></code></pre></td></tr></table></figure><h4 id="2-5-3-元素访问"><a href="#2-5-3-元素访问" class="headerlink" title="2.5.3 元素访问"></a>2.5.3 元素访问</h4><ul><li><code>front</code></li></ul><h4 id="2-5-4-迭代器"><a href="#2-5-4-迭代器" class="headerlink" title="2.5.4 迭代器"></a>2.5.4 迭代器</h4><ul><li><code>before_begin</code> <code>cbefore_begin</code>：返回指向第一个元素之前迭代器</li><li><code>begin</code> <code>cbegin</code></li><li><code>end</code> <code>cend</code></li></ul><p><em>注：无反向迭代器，迭代器只支持<strong>自增</strong>运算</em></p><h4 id="2-5-5-容量"><a href="#2-5-5-容量" class="headerlink" title="2.5.5 容量"></a>2.5.5 容量</h4><ul><li><code>empty</code></li><li><code>max_size</code></li></ul><p><em>注：不提供<code>size</code></em></p><h4 id="2-5-6-修改"><a href="#2-5-6-修改" class="headerlink" title="2.5.6 修改"></a>2.5.6 修改</h4><ul><li><code>clear</code></li><li><code>insert_after</code>：在某个元素后插入新元素</li><li><code>emplace_after</code>：在元素后原位构造元素</li><li><code>erase_after</code>：擦除元素后的元素</li><li><code>push_front</code></li><li><code>emplace_front</code></li><li><code>pop_front</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">emplace_after</span>(ifwlist.<span class="hljs-built_in">cbefore_begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// ifwlist: &#123;0, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>resize</code></li><li><code>swap</code></li></ul><h4 id="2-5-7-操作"><a href="#2-5-7-操作" class="headerlink" title="2.5.7 操作"></a>2.5.7 操作</h4><ul><li><code>merge</code>：合并二个<strong>已排序</strong>列表。操作后<code>other</code>会变为空<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 链表应以升序排序，默认调用operator&lt;比较元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(forward_list &amp;other)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(forward_list &amp;&amp;other)</span></span>;<br><br><span class="hljs-comment">// 使用给定的比较函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(forward_list &amp;other, Compare comp)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(forward_list &amp;&amp;other, Compare comp)</span></span>;<br><br><span class="hljs-comment">// 比较函数的签名应等价于如下</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Type1 &amp;a, <span class="hljs-type">const</span> Type2 &amp;b)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, other&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">merge</span>(other); <span class="hljs-comment">// ifwlist: &#123;0, 1, 2, 3, 4, 5&#125;</span><br><br><span class="hljs-keyword">if</span> (other.<span class="hljs-built_in">empty</span>())<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;empty&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// empty</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, other&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">merge</span>(other, std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// ifwlist: &#123;5, 4, 3, 2, 1, 0&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>splice_after</code>：从另一<code>forward_list</code>移动元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// other所有元素移动到*this的pos后</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;other)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;&amp;other)</span></span>;<br><br><span class="hljs-comment">// it为待插入元素的前向迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;other, const_iterator it)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;&amp;other, const_iterator it)</span></span>;<br><br><span class="hljs-comment">// (first, last)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;other, const_iterator first, const_iterator last)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span><span class="hljs-params">(const_iterator pos, forward_list &amp;&amp;other, const_iterator first, const_iterator last)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, other&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">splice_after</span>(ifwlist.<span class="hljs-built_in">cbefore_begin</span>(), other, other.<span class="hljs-built_in">cbegin</span>()); <span class="hljs-comment">// ifwlist: &#123;5, 0, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, other&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">splice_after</span>(ifwlist.<span class="hljs-built_in">cbefore_begin</span>(), other, other.<span class="hljs-built_in">cbegin</span>(), other.<span class="hljs-built_in">cend</span>()); <span class="hljs-comment">// ifwlist: &#123;5, 6, 0, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>remove</code> <code>remove_if</code>：移除满足特定标准的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value)</span></span>;<br><br><span class="hljs-comment">// p：若应该移除该元素则返回true的一元谓词</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryPredicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_if</span><span class="hljs-params">(UnaryPredicate p)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">int</span> _x;<br>    <span class="hljs-type">int</span> _y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : _x(x), _y(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isOnYAxis</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> !p._x;<br>&#125;<br><br>std::forward_list&lt;Point&gt; fwlist&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>fwlist.<span class="hljs-built_in">remove_if</span>(isOnYAxis); <span class="hljs-comment">// fwlist: &#123;&#123;1, 0&#125;, &#123;1, 1&#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>reverse</code>：将该链表的所有元素的顺序反转</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>unique</code>：删除<strong>连续</strong>的重复元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 用operator==比较元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 用二元谓词p比较元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryPredicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unique</span><span class="hljs-params">(BinaryPredicate p)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-type">int</span> birth_year;<br>    <span class="hljs-type">int</span> birth_month;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month) : <span class="hljs-built_in">birth_year</span>(year), <span class="hljs-built_in">birth_month</span>(month) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;lhs, <span class="hljs-type">const</span> Person &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (lhs.birth_year == rhs.birth_year)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>std::forward_list&lt;Person&gt; fwlist&#123;&#123;<span class="hljs-number">2001</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2001</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2001</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">2001</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2002</span>, <span class="hljs-number">5</span>&#125;&#125;;<br><br>fwlist.<span class="hljs-built_in">unique</span>(isSameAge); <span class="hljs-comment">// fwlist: &#123;&#123;2001, 1&#125;, &#123;2000, 3&#125;, &#123;2001, 1&#125;, &#123;2002, 5&#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>sort</code>：对元素进行排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 升序，默认调用operator&lt;比较元素</span><br><br><span class="hljs-comment">// 使用给定的比较函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Compare comp)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::forward_list&lt;<span class="hljs-type">int</span>&gt; ifwlist&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br><br>ifwlist.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// ifwlist: &#123;0, 1, 2, 3, 4, 5&#125;</span><br><br>ifwlist.<span class="hljs-built_in">sort</span>(std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// ifwlist: &#123;5, 4, 3, 2, 1, 0&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-8-其他成员函数"><a href="#2-5-8-其他成员函数" class="headerlink" title="2.5.8 其他成员函数"></a>2.5.8 其他成员函数</h4><p>同<code>deque</code></p><hr><h3 id="2-6-list"><a href="#2-6-list" class="headerlink" title="2.6 list"></a>2.6 <code>list</code></h3><h4 id="2-6-1-类模板声明"><a href="#2-6-1-类模板声明" class="headerlink" title="2.6.1 类模板声明"></a>2.6.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> list;<br></code></pre></td></tr></table></figure><h4 id="2-6-2-构造函数"><a href="#2-6-2-构造函数" class="headerlink" title="2.6.2 构造函数"></a>2.6.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">list</span><span class="hljs-params">(size_type count, <span class="hljs-type">const</span> T &amp;value = T(), <span class="hljs-type">const</span> Allocator &amp;alloc = Allocator())</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">list</span><span class="hljs-params">(size_type count)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-built_in">list</span>(InputIt first, InputIt last, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// [first, last)</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list &amp;other);<br><br><span class="hljs-built_in">list</span>(list &amp;&amp;other); <span class="hljs-comment">// C++11</span><br><br><span class="hljs-built_in">list</span>(std::initializer_list&lt;T&gt; init, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// C++11</span><br></code></pre></td></tr></table></figure><h4 id="2-6-3-元素访问"><a href="#2-6-3-元素访问" class="headerlink" title="2.6.3 元素访问"></a>2.6.3 元素访问</h4><ul><li><p><code>front</code></p></li><li><p><code>back</code></p></li></ul><h4 id="2-6-4-迭代器"><a href="#2-6-4-迭代器" class="headerlink" title="2.6.4 迭代器"></a>2.6.4 迭代器</h4><ul><li><p><code>begin</code> <code>cbegin</code></p></li><li><p><code>end</code> <code>cend</code></p></li><li><p><code>rbegin</code> <code>crbegin</code></p></li><li><p><code>rend</code> <code>crend</code></p></li></ul><h4 id="2-6-5-容量"><a href="#2-6-5-容量" class="headerlink" title="2.6.5 容量"></a>2.6.5 容量</h4><ul><li><code>empty</code></li><li><code>size</code></li><li><code>max_size</code></li></ul><h4 id="2-6-6-修改"><a href="#2-6-6-修改" class="headerlink" title="2.6.6 修改"></a>2.6.6 修改</h4><p>同<code>deque</code></p><h4 id="2-6-7-操作"><a href="#2-6-7-操作" class="headerlink" title="2.6.7 操作"></a>2.6.7 操作</h4><p>同<code>forward_list</code></p><h4 id="2-6-8-其他成员函数"><a href="#2-6-8-其他成员函数" class="headerlink" title="2.6.8 其他成员函数"></a>2.6.8 其他成员函数</h4><p>同<code>deque</code></p><hr><h3 id="2-7-string"><a href="#2-7-string" class="headerlink" title="2.7 string"></a>2.7 <code>string</code></h3><h4 id="2-7-1-类模板声明"><a href="#2-7-1-类模板声明" class="headerlink" title="2.7.1 类模板声明"></a>2.7.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CharT</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traits</span> = std::char_traits&lt;CharT&gt;, <span class="hljs-keyword">class</span> Allocator = std::allocator&lt;CharT&gt;&gt;<br><span class="hljs-keyword">class</span> basic_string;<br><br><span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-type">char</span>&gt; string;<br></code></pre></td></tr></table></figure><h4 id="2-7-2-构造函数"><a href="#2-7-2-构造函数" class="headerlink" title="2.7.2 构造函数"></a>2.7.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">basic_string</span>();<br><br><span class="hljs-built_in">basic_string</span>(size_type count, CharT ch, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-comment">// [pos, other.size())</span><br><span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> basic_string &amp;other, size_type pos, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());               <br><br><span class="hljs-comment">// [pos, pos + count)</span><br><span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> basic_string &amp;other, size_type pos, size_type count, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-comment">// [s, s + count)</span><br><span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> CharT *s, size_type count, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> CharT *s, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-comment">// [first, last) </span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-built_in">basic_string</span>(InputIt first, InputIt last, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> basic_string &amp;other);<br><br><span class="hljs-built_in">basic_string</span>(basic_string &amp;&amp;other) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// C++11</span><br><br><span class="hljs-built_in">basic_string</span>(std::initializer_list&lt;CharT&gt; ilist, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// C++11</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br><br>std::string s1;                                   <span class="hljs-comment">// 空字符串</span><br><span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(s)</span></span>;                                <span class="hljs-comment">// &quot;abcdefg&quot;</span><br><span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;                           <span class="hljs-comment">// &quot;aaa&quot;</span><br><span class="hljs-function">std::string <span class="hljs-title">s4</span><span class="hljs-params">(s2, <span class="hljs-number">2</span>)</span></span>;                            <span class="hljs-comment">// &quot;cdefg&quot;</span><br><span class="hljs-function">std::string <span class="hljs-title">s5</span><span class="hljs-params">(s2, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;                         <span class="hljs-comment">// &quot;cde&quot;, [pos, pos + count)</span><br><span class="hljs-function">std::string <span class="hljs-title">s6</span><span class="hljs-params">(s, <span class="hljs-number">4</span>)</span></span>;                             <span class="hljs-comment">// &quot;abcd&quot;, [s, s + count)</span><br><span class="hljs-function">std::string <span class="hljs-title">s7</span><span class="hljs-params">(s2.cbegin() + <span class="hljs-number">2</span>, s2.cbegin() + <span class="hljs-number">6</span>)</span></span>; <span class="hljs-comment">// &quot;cdef&quot;, [first, last)</span><br><span class="hljs-function">std::string <span class="hljs-title">s8</span><span class="hljs-params">(s2)</span></span>;                               <span class="hljs-comment">// &quot;abcdefg&quot;, copy constructor</span><br><span class="hljs-function">std::string <span class="hljs-title">s9</span><span class="hljs-params">(std::move(s2))</span></span>;                    <span class="hljs-comment">// move constructor，s2的值未定义，s9为&quot;abcdefg&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-7-3-元素访问"><a href="#2-7-3-元素访问" class="headerlink" title="2.7.3 元素访问"></a>2.7.3 元素访问</h4><ul><li><code>at</code></li><li><code>operator[]</code></li><li><code>front</code></li><li><code>back</code></li><li><code>data</code></li><li><code>c_str</code>：将<code>string</code>对象转换为C风格字符串，<code>c_str</code>与 <code>data</code>功能相同。通过 <code>c_str()</code> 写入字符数组是未定义行为</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> CharT* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-string">&#x27;\0&#x27;</span> != str[i]; ++i)<br>        std::cout &lt;&lt; str[i];<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><span class="hljs-built_in">print</span>(s.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">//  Hello World</span><br></code></pre></td></tr></table></figure><h4 id="2-7-4-迭代器"><a href="#2-7-4-迭代器" class="headerlink" title="2.7.4 迭代器"></a>2.7.4 迭代器</h4><ul><li><code>begin</code> <code>cbegin</code></li><li><code>end</code> <code>cend</code></li><li><code>rbegin</code> <code>crbegin</code></li><li><code>rend</code> <code>crend</code></li></ul><h4 id="2-7-5-容量"><a href="#2-7-5-容量" class="headerlink" title="2.7.5 容量"></a>2.7.5 容量</h4><ul><li><p><code>empty</code></p></li><li><p><code>size</code> <code>lenghth</code>：返回字符数</p></li><li><p><code>max_size</code></p></li><li><p><code>reserve</code>：设置预留空间大小，避免不断重新分配内存</p></li><li><p><code>capacity</code>：返回当前对象分配的存储空间能保存的字符数量</p></li><li><p><code>shrink_to_fit</code>：通过释放不使用内存减少内存使用，减少<code>capacity</code>到<code>size</code>的非强制请求，<strong>是否满足请求取依赖于实现</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(size_type new_cap = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink_to_fit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>std::cout &lt;&lt; s.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;<br>s.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">50</span>);<br>std::cout &lt;&lt; s.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;<br>s.<span class="hljs-built_in">shrink_to_fit</span>();<br>std::cout &lt;&lt; s.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可能的输出</span><br><span class="hljs-comment">20</span><br><span class="hljs-comment">50</span><br><span class="hljs-comment">20</span><br><span class="hljs-comment">/*</span><br></code></pre></td></tr></table></figure><h4 id="2-7-6-操作"><a href="#2-7-6-操作" class="headerlink" title="2.7.6 操作"></a>2.7.6 操作</h4><ul><li><code>clear</code></li><li><code>insert</code></li><li><code>erase</code></li><li><code>push_back</code></li><li><code>pop_back</code></li><li><code>append</code></li><li><code>operator+=</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">basic_string &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> basic_string &amp;str);<br>basic_string &amp;<span class="hljs-keyword">operator</span>+=(CharT ch);<br>basic_string &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> CharT *s);<br>basic_string &amp;<span class="hljs-keyword">operator</span>+=(std::initializer_list&lt;CharT&gt; ilist);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span>, <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot; Worl&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">ch</span><span class="hljs-params">(<span class="hljs-string">&#x27;d&#x27;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><br>s += s1; <span class="hljs-comment">// &quot;Hello Worl&quot;</span><br>s += ch; <span class="hljs-comment">// &quot;Hello World&quot;</span><br>s.<span class="hljs-built_in">clear</span>();<br>s += str;<br>s += &#123;<span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>&#125;; <span class="hljs-comment">// &quot;Hello World!!!&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>compare</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> basic_string &amp;str)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(size_type pos1, size_type count1, <span class="hljs-type">const</span> basic_string &amp;str)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(size_type pos1, size_type count1, <span class="hljs-type">const</span> basic_string &amp;str, size_type pos2, size_type count2)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> CharT *s)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(size_type pos1, size_type count1, <span class="hljs-type">const</span> CharT *s)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(size_type pos1, size_type count1, <span class="hljs-type">const</span> CharT *s, size_type count2)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>starts_with</code><em>(C++20)</em></li><li><code>ends_with</code><em>(C++20)</em></li><li><code>contains</code><em>(C++23)</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(CharT c)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">const</span> CharT *s)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>replace</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(size_type pos, size_type count, <span class="hljs-type">const</span> basic_string &amp;str)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, <span class="hljs-type">const</span> basic_string &amp;str)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(size_type pos, size_type count, <span class="hljs-type">const</span> basic_string &amp;str, size_type pos2, size_type count2)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(size_type pos, size_type count, <span class="hljs-type">const</span> CharT *cstr, size_type count2)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, <span class="hljs-type">const</span> CharT *cstr, size_type count2)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(size_type pos, size_type count, <span class="hljs-type">const</span> CharT *cstr)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, <span class="hljs-type">const</span> CharT *cstr)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(size_type pos, size_type count, size_type count2, CharT ch)</span></span>;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, size_type count2, CharT ch)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, InputIt first2, InputIt last2)</span></span>;<br><br><span class="hljs-function">basic_string &amp;<span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, std::initializer_list&lt;CharT&gt; ilist)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>substr</code>：返回子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">basic_string <span class="hljs-title">substr</span><span class="hljs-params">(size_type pos = <span class="hljs-number">0</span>, size_type count = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// [pos, pos + count)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><br>std::cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// llo</span><br></code></pre></td></tr></table></figure><ul><li><code>copy</code>：复制字符，<strong>产生的字符串不是空终止的</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">size_type <span class="hljs-title">copy</span><span class="hljs-params">(CharT *dest, size_type count, size_type pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 复制子串[pos, pos + count)到dest</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">char</span> arr[<span class="hljs-number">6</span>];<br><span class="hljs-built_in">memset</span>(arr, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]));<br><br><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br>s.<span class="hljs-built_in">copy</span>(arr, <span class="hljs-number">5</span>);<br>std::cout &lt;&lt; arr &lt;&lt; std::endl; <span class="hljs-comment">// Helloa</span><br></code></pre></td></tr></table></figure><ul><li><code>resize</code></li><li><code>swap</code></li></ul><h4 id="2-7-7-查找"><a href="#2-7-7-查找" class="headerlink" title="2.7.7 查找"></a>2.7.7 查找</h4><ul><li><code>find</code></li><li><code>rfind</code></li><li><code>find_first_of</code></li><li><code>find_first_not_of</code></li><li><code>find_last_of</code></li><li><code>find_last_not_of</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 其他五个只有函数名不同</span><br><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> basic_string &amp;str, size_type pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> CharT *s, size_type pos, size_type count)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> CharT *s, size_type pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">(CharT ch, size_type pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2-7-8-常量"><a href="#2-7-8-常量" class="headerlink" title="2.7.8 常量"></a>2.7.8 常量</h4><ul><li><code>npos</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> size_type npos = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 特殊值，等于size_type类型可表示的最大值</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string s = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>) == std::string::npos)<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;no &#x27;a&#x27; in &#x27;test&#x27;\n&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-7-9-数制转换（非成员函数）"><a href="#2-7-9-数制转换（非成员函数）" class="headerlink" title="2.7.9 数制转换（非成员函数）"></a>2.7.9 数制转换（非成员函数）</h4><p>所需头文件<code>&lt;string&gt;</code></p><ul><li><code>stoi</code><em>(C++11)</em></li><li><code>stol</code><em>(C++11)</em></li><li><code>stoll</code><em>(C++11)</em></li><li><code>stoul</code> <code>stoull</code><em>(C++11)</em></li><li><code>stof</code> <code>stod</code> <code>stold</code><em>(C++11)</em></li><li><code>to_string</code><em>(C++11)</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoi</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str, std::<span class="hljs-type">size_t</span> *pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 底的合法集是&#123;0,2,3,...,36&#125;</span><br>...<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">stof</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str, std::<span class="hljs-type">size_t</span> *pos = <span class="hljs-number">0</span>)</span></span>;<br>...<br><span class="hljs-function">std::string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;111&quot;</span>)</span></span>;<br><br>std::cout &lt;&lt; std::<span class="hljs-built_in">stoi</span>(s, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 7</span><br><br>std::cout &lt;&lt; std::<span class="hljs-built_in">to_string</span>(<span class="hljs-number">1.2e+4</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 12000.000000</span><br></code></pre></td></tr></table></figure><h4 id="2-7-10-其他成员函数"><a href="#2-7-10-其他成员函数" class="headerlink" title="2.7.10 其他成员函数"></a>2.7.10 其他成员函数</h4><p>同<code>deque</code></p><h3 id="2-8-vector"><a href="#2-8-vector" class="headerlink" title="2.8 vector"></a>2.8 <code>vector</code></h3><h4 id="2-8-1-类模板声明"><a href="#2-8-1-类模板声明" class="headerlink" title="2.8.1 类模板声明"></a>2.8.1 类模板声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector;<br></code></pre></td></tr></table></figure><h4 id="2-8-2-构造函数"><a href="#2-8-2-构造函数" class="headerlink" title="2.8.2 构造函数"></a>2.8.2 构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>();<br><br><span class="hljs-built_in">vector</span>(size_type count, <span class="hljs-type">const</span> T &amp;value, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">vector</span><span class="hljs-params">(size_type count)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-built_in">vector</span>(InputIt first, InputIt last, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>());<br><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector &amp;other);<br><br><span class="hljs-built_in">vector</span>(vector &amp;&amp;other); <span class="hljs-comment">// C++11</span><br><br><span class="hljs-built_in">vector</span>(std::initializer_list&lt;T&gt; init, <span class="hljs-type">const</span> Allocator &amp;alloc = <span class="hljs-built_in">Allocator</span>()); <span class="hljs-comment">// C++11</span><br></code></pre></td></tr></table></figure><h4 id="2-8-3-元素访问"><a href="#2-8-3-元素访问" class="headerlink" title="2.8.3 元素访问"></a>2.8.3 元素访问</h4><ul><li><p><code>at</code></p></li><li><p><code>operator[]</code></p></li><li><p><code>front</code></p></li><li><p><code>back</code></p></li><li><p><code>data</code></p></li></ul><h4 id="2-8-4-迭代器"><a href="#2-8-4-迭代器" class="headerlink" title="2.8.4 迭代器"></a>2.8.4 迭代器</h4><ul><li><code>begin</code> <code>cbegin</code></li><li><code>end</code> <code>cend</code></li><li><code>rbegin</code> <code>crbegin</code></li><li><code>rend</code> <code>crend</code></li></ul><h4 id="2-8-5-容量"><a href="#2-8-5-容量" class="headerlink" title="2.8.5 容量"></a>2.8.5 容量</h4><ul><li><code>empty</code></li><li><code>size</code> </li><li><code>max_size</code></li><li><code>reserve</code></li><li><code>capacity</code></li><li><code>shrink_to_fit</code></li></ul><h4 id="2-8-6-修改"><a href="#2-8-6-修改" class="headerlink" title="2.8.6 修改"></a>2.8.6 修改</h4><ul><li><code>clear</code></li><li><code>insert</code></li><li><code>emplace</code><em>(C++11)</em></li><li><code>erase</code></li><li><code>push_back</code></li><li><code>emplace_back</code><em>(C++11)</em></li><li><code>pop_back</code></li><li><code>resize</code></li><li><code>swap</code></li></ul><h4 id="2-8-7-特化"><a href="#2-8-7-特化" class="headerlink" title="2.8.7 特化"></a>2.8.7 特化</h4><p><code>vector&lt;bool&gt;</code> ：节省空间的动态<code>bitset </code></p><h4 id="2-8-8-其他成员函数"><a href="#2-8-8-其他成员函数" class="headerlink" title="2.8.8 其他成员函数"></a>2.8.8 其他成员函数</h4><p>同<code>deque</code></p>]]></content>
    
    
    <categories>
      
      <category>Reading Notes</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
